<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode Problem Rating</title>
      <link href="/2021/12/31/Leetcode-Problem-Rating/"/>
      <url>/2021/12/31/Leetcode-Problem-Rating/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-Problem-Rating"><a href="#Leetcode-Problem-Rating" class="headerlink" title="Leetcode Problem Rating"></a>Leetcode Problem Rating</h1><h2 id="Personal-CheckList"><a href="#Personal-CheckList" class="headerlink" title="Personal CheckList"></a>Personal CheckList</h2><table><thead><tr><th>Finished</th><th>Rating</th><th>ID</th><th>Title</th><th>Comment</th></tr></thead><tbody><tr><td>&#9745;</td><td>3018.49</td><td>1719</td><td>Number Of Ways To Reconstruct A Tree</td><td>乍看是Graph問題，如果有看出是排列組合問題應該就不是難題了，另外需要會模反知識。</td></tr><tr><td>&#9745;</td><td>2872.03</td><td>1982</td><td>Find Array Given Subset Sums</td><td><a href="https://www.codechef.com/problems/ANUMLA">原題都是非負數</a>。負最小跟正最大值顯然就是全負或是全正的集合，再觀察如果<code>所有當前集合</code>都扣掉<code>全負集合</code>，集合的結構如何變化? 這題需要再多複習。</td></tr><tr><td>&#9744;</td><td>2863.14</td><td>770</td><td>Basic Calculator IV</td><td></td></tr><tr><td>&#9744;</td><td>2849.48</td><td>1728</td><td>Cat and Mouse II</td><td></td></tr><tr><td>&#9744;</td><td>2817.27</td><td>1977</td><td>Number of Ways to Separate Numbers</td><td></td></tr><tr><td>&#9744;</td><td>2803.77</td><td>2060</td><td>Check if an Original String Exists Given Two Encoded Strings</td><td></td></tr><tr><td>&#9744;</td><td>2765.25</td><td>803</td><td>Bricks Falling When Hit</td><td></td></tr><tr><td>&#9744;</td><td>2690.59</td><td>1960</td><td>Maximum Product of the Length of Two Palindromic Substrings</td><td></td></tr><tr><td>&#9744;</td><td>2666.67</td><td>1397</td><td>Find All Good Strings</td><td></td></tr><tr><td>&#9744;</td><td>2661.07</td><td>1923</td><td>Longest Common Subpath</td><td></td></tr><tr><td>&#9744;</td><td>2655.22</td><td>1659</td><td>Maximize Grid Happiness</td><td></td></tr><tr><td>&#9744;</td><td>2650.90</td><td>2097</td><td>Valid Arrangement of Pairs</td><td></td></tr><tr><td>&#9744;</td><td>2648.17</td><td>2071</td><td>Maximum Number of Tasks You Can Assign</td><td></td></tr><tr><td>&#9744;</td><td>2640.38</td><td>1787</td><td>Make the XOR of All Segments Equal to Zero</td><td></td></tr><tr><td>&#9744;</td><td>2620.42</td><td>1830</td><td>Minimum Number of Operations to Make String Sorted</td><td></td></tr><tr><td>&#9744;</td><td>2610.99</td><td>2056</td><td>Number of Valid Move Combinations On Chessboard</td><td></td></tr><tr><td>&#9744;</td><td>2610.08</td><td>1687</td><td>Delivering Boxes from Storage to Ports</td><td></td></tr><tr><td>&#9744;</td><td>2594.14</td><td>964</td><td>Least Operators to Express Number</td><td></td></tr><tr><td>&#9744;</td><td>2587.87</td><td>1883</td><td>Minimum Skips to Arrive at Meeting On Time</td><td></td></tr><tr><td>&#9744;</td><td>2583.90</td><td>2019</td><td>The Score of Students Solving Math Expression</td><td></td></tr><tr><td>&#9744;</td><td>2583.41</td><td>936</td><td>Stamping The Sequence</td><td></td></tr><tr><td>&#9744;</td><td>2575.96</td><td>1531</td><td>String Compression II</td><td></td></tr><tr><td>&#9744;</td><td>2571.55</td><td>1489</td><td>Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree</td><td></td></tr><tr><td>&#9744;</td><td>2566.59</td><td>913</td><td>Cat and Mouse</td><td></td></tr><tr><td>&#9744;</td><td>2561.78</td><td>2030</td><td>Smallest K-Length Subsequence With Occurrences of a Letter</td><td></td></tr><tr><td>&#9744;</td><td>2559.44</td><td>1815</td><td>Maximum Number of Groups Getting Fresh Donuts</td><td></td></tr><tr><td>&#9744;</td><td>2558.33</td><td>2014</td><td>Longest Subsequence Repeated k Times</td><td></td></tr><tr><td>&#9744;</td><td>2539.86</td><td>1819</td><td>Number of Different Subsequences GCDs</td><td></td></tr><tr><td>&#9744;</td><td>2537.80</td><td>1595</td><td>Minimum Cost to Connect Two Groups of Points</td><td></td></tr><tr><td>&#9744;</td><td>2533.78</td><td>1948</td><td>Delete Duplicate Folders in System</td><td></td></tr><tr><td>&#9744;</td><td>2533.30</td><td>1675</td><td>Minimize Deviation in Array</td><td></td></tr><tr><td>&#9744;</td><td>2531.65</td><td>1896</td><td>Minimum Cost to Change the Final Value of Expression</td><td></td></tr><tr><td>&#9744;</td><td>2530.69</td><td>1776</td><td>Car Fleet II</td><td></td></tr><tr><td>&#9744;</td><td>2529.53</td><td>1632</td><td>Rank Transform of a Matrix</td><td></td></tr><tr><td>&#9744;</td><td>2517.68</td><td>2040</td><td>Kth Smallest Product of Two Sorted Arrays</td><td></td></tr><tr><td>&#9744;</td><td>2502.52</td><td>1938</td><td>Maximum Genetic Difference Query</td><td></td></tr><tr><td>&#9744;</td><td>2499.56</td><td>1735</td><td>Count Ways to Make Array With Product</td><td></td></tr><tr><td>&#9744;</td><td>2489.67</td><td>2035</td><td>Partition Array Into Two Arrays to Minimize Sum Difference</td><td></td></tr><tr><td>&#9744;</td><td>2486.23</td><td>1916</td><td>Count Ways to Build Rooms in an Ant Colony</td><td></td></tr><tr><td>&#9744;</td><td>2483.94</td><td>1932</td><td>Merge BSTs to Create Single BST</td><td></td></tr><tr><td>&#9744;</td><td>2481.72</td><td>1330</td><td>Reverse Subarray To Maximize Array Value</td><td></td></tr><tr><td>&#9744;</td><td>2479.33</td><td>1803</td><td>Count Pairs With XOR in a Range</td><td></td></tr><tr><td>&#9744;</td><td>2476.45</td><td>1622</td><td>Fancy Sequence</td><td></td></tr><tr><td>&#9744;</td><td>2466.89</td><td>1703</td><td>Minimum Adjacent Swaps for K Consecutive Ones</td><td></td></tr><tr><td>&#9744;</td><td>2464.51</td><td>1994</td><td>The Number of Good Subsets</td><td></td></tr><tr><td>&#9744;</td><td>2457.12</td><td>1782</td><td>Count Pairs Of Nodes</td><td></td></tr><tr><td>&#9744;</td><td>2456.39</td><td>1499</td><td>Max Value of Equation</td><td></td></tr><tr><td>&#9744;</td><td>2455.82</td><td>1040</td><td>Moving Stones Until Consecutive II</td><td></td></tr><tr><td>&#9744;</td><td>2454.77</td><td>1900</td><td>The Earliest and Latest Rounds Where Players Compete</td><td></td></tr><tr><td>&#9744;</td><td>2439.73</td><td>1872</td><td>Stone Game VIII</td><td></td></tr><tr><td>&#9744;</td><td>2433.38</td><td>903</td><td>Valid Permutations for DI Sequence</td><td></td></tr><tr><td>&#9744;</td><td>2429.67</td><td>782</td><td>Transform to Chessboard</td><td></td></tr><tr><td>&#9744;</td><td>2429.09</td><td>1998</td><td>GCD Sort of an Array</td><td></td></tr><tr><td>&#9744;</td><td>2428.80</td><td>1044</td><td>Longest Duplicate Substring</td><td></td></tr><tr><td>&#9744;</td><td>2422.53</td><td>1000</td><td>Minimum Cost to Merge Stones</td><td></td></tr><tr><td>&#9744;</td><td>2422.31</td><td>1987</td><td>Number of Unique Good Subsequences</td><td></td></tr><tr><td>&#9744;</td><td>2418.57</td><td>1203</td><td>Sort Items by Groups Respecting Dependencies</td><td></td></tr><tr><td>&#9744;</td><td>2415.01</td><td>2003</td><td>Smallest Missing Genetic Value in Each Subtree</td><td></td></tr><tr><td>&#9744;</td><td>2413.40</td><td>1928</td><td>Minimum Cost to Reach Destination in Time</td><td></td></tr><tr><td>&#9744;</td><td>2409.76</td><td>1388</td><td>Pizza With 3n Slices</td><td></td></tr><tr><td>&#9744;</td><td>2399.57</td><td>920</td><td>Number of Music Playlists</td><td></td></tr><tr><td>&#9744;</td><td>2396.63</td><td>808</td><td>Soup Servings</td><td></td></tr><tr><td>&#9744;</td><td>2395.88</td><td>1825</td><td>Finding MK Average</td><td></td></tr><tr><td>&#9744;</td><td>2391.81</td><td>818</td><td>Race Car</td><td></td></tr><tr><td>&#9744;</td><td>2389.96</td><td>1681</td><td>Minimum Incompatibility</td><td></td></tr><tr><td>&#9744;</td><td>2385.81</td><td>1349</td><td>Maximum Students Taking Exam</td><td></td></tr><tr><td>&#9744;</td><td>2383.77</td><td>1521</td><td>Find a Value of a Mysterious Function Closest to Target</td><td></td></tr><tr><td>&#9744;</td><td>2381.48</td><td>956</td><td>Tallest Billboard</td><td></td></tr><tr><td>&#9744;</td><td>2378.62</td><td>757</td><td>Set Intersection Size At Least Two</td><td></td></tr><tr><td>&#9744;</td><td>2377.39</td><td>854</td><td>K-Similar Strings</td><td></td></tr><tr><td>&#9744;</td><td>2376.87</td><td>887</td><td>Super Egg Drop</td><td></td></tr><tr><td>&#9744;</td><td>2374.19</td><td>1840</td><td>Maximum Building Height</td><td></td></tr><tr><td>&#9744;</td><td>2366.71</td><td>1183</td><td>Maximum Number of Ones</td><td></td></tr><tr><td>&#9744;</td><td>2363.51</td><td>1755</td><td>Closest Subsequence Sum</td><td></td></tr><tr><td>&#9744;</td><td>2362.65</td><td>1520</td><td>Maximum Number of Non-Overlapping Substrings</td><td></td></tr><tr><td>&#9744;</td><td>2358.97</td><td>1707</td><td>Maximum XOR With an Element From Array</td><td></td></tr><tr><td>&#9744;</td><td>2356.58</td><td>1467</td><td>Probability of a Two Boxes Having The Same Number of Distinct Balls</td><td></td></tr><tr><td>&#9744;</td><td>2350.97</td><td>1713</td><td>Minimum Operations to Make a Subsequence</td><td></td></tr><tr><td>&#9744;</td><td>2350.04</td><td>837</td><td>New 21 Game</td><td></td></tr><tr><td>&#9744;</td><td>2348.52</td><td>1096</td><td>Brace Expansion II</td><td></td></tr><tr><td>&#9744;</td><td>2345.34</td><td>1611</td><td>Minimum One Bit Operations to Make Integers Zero</td><td></td></tr><tr><td>&#9744;</td><td>2341.45</td><td>810</td><td>Chalkboard XOR Game</td><td></td></tr><tr><td>&#9744;</td><td>2336.52</td><td>1505</td><td>Minimum Possible Integer After at Most K Adjacent Swaps On Digits</td><td></td></tr><tr><td>&#9744;</td><td>2333.24</td><td>1674</td><td>Minimum Moves to Make Array Complementary</td><td></td></tr><tr><td>&#9744;</td><td>2333.06</td><td>1866</td><td>Number of Ways to Rearrange Sticks With K Sticks Visible</td><td></td></tr><tr><td>&#9744;</td><td>2333.01</td><td>1585</td><td>Check If String Is Transformable With Substring Sort Operations</td><td></td></tr><tr><td>&#9744;</td><td>2328.43</td><td>882</td><td>Reachable Nodes In Subdivided Graph</td><td></td></tr><tr><td>&#9744;</td><td>2315.60</td><td>1187</td><td>Make Array Strictly Increasing</td><td></td></tr><tr><td>&#9744;</td><td>2312.99</td><td>1857</td><td>Largest Color Value in a Directed Graph</td><td></td></tr><tr><td>&#9744;</td><td>2310.38</td><td>1959</td><td>Minimum Total Space Wasted With K Resizing Operations</td><td></td></tr><tr><td>&#9745;</td><td>2308.65</td><td>1617</td><td>Count Subtrees With Max Distance Between Cities</td><td>2021.12.30 寫得有點太複雜，我對每個bitmask都先確認連通再求直徑。 之前寫過的解是從最小的連通塊開始長大，因此不用再判斷連通，只要小心別重複計算即可，不過未必比較好就是了。雖然計算Graph的直徑確實可以用dfs，但本題可以事先用Floyd-Warshall algorithm建立距離表，程式碼會比較簡潔，惟複雜度會比較高。</td></tr><tr><td>&#9745;</td><td>2307.02</td><td>1655</td><td>Distribute Repeating Integers</td><td>2021.12.30 簡單，題目要仔細看，竟然漏掉m=10這個超強限制，可以想想如果m很大的話能不能解</td></tr><tr><td>&#9745;</td><td>2306.85</td><td>862</td><td>Shortest Subarray with Sum at Least K</td><td>2021.12.30 簡單</td></tr><tr><td>&#9745;</td><td>2300.16</td><td>1697</td><td>Checking Existence of Edge Length Limited Paths</td><td>2021.12.30 簡單，我以前竟然在比賽沒解出這題</td></tr></tbody></table><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><ul><li><a href="https://github.com/zerotrac/leetcode_problem_rating/tree/gh-pages">零神: Leetcode Problem Rating</a></li></ul><h2 id="Covert-Data-to-Markdown"><a href="#Covert-Data-to-Markdown" class="headerlink" title="Covert Data to Markdown"></a>Covert Data to Markdown</h2><ul><li>Step1: Data Preprocess to Json</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token comment" spellcheck="true"># Read Json</span>FILE_NAME <span class="token operator">=</span> <span class="token string">"./data.json"</span>df <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_json<span class="token punctuation">(</span>FILE_NAME<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Preprocess</span>mask <span class="token operator">=</span> df<span class="token punctuation">[</span><span class="token string">"Rating"</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">2300</span>df <span class="token operator">=</span> df<span class="token punctuation">[</span>mask<span class="token punctuation">]</span>df<span class="token punctuation">[</span><span class="token string">"Rating"</span><span class="token punctuation">]</span> <span class="token operator">=</span> df<span class="token punctuation">[</span><span class="token string">"Rating"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token string">"{0:.2f}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>df<span class="token punctuation">[</span><span class="token string">"Finished"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"&amp;#9744;"</span>df<span class="token punctuation">[</span><span class="token string">"Comment"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">" "</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token comment" spellcheck="true"># check: &amp;#9745; </span><span class="token comment" spellcheck="true"># uncheck: &amp;#9744;</span><span class="token comment" spellcheck="true"># Ouput</span>COLS <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Finished"</span><span class="token punctuation">,</span> <span class="token string">"Rating"</span><span class="token punctuation">,</span> <span class="token string">"ID"</span><span class="token punctuation">,</span> <span class="token string">"Title"</span><span class="token punctuation">,</span> <span class="token string">"Comment"</span><span class="token punctuation">]</span>res_df <span class="token operator">=</span> df<span class="token punctuation">[</span>COLS<span class="token punctuation">]</span>res_df<span class="token punctuation">.</span>to_json<span class="token punctuation">(</span><span class="token string">"./problem_list.json"</span><span class="token punctuation">,</span> orient <span class="token operator">=</span> <span class="token string">'records'</span><span class="token punctuation">)</span></code></pre><ul><li>Step2: <a href="https://kdelmonte.github.io/json-to-markdown-table/">JSON to Markdown Table</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Competitive Programming </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 2117. Abbreviating the Product of a Range</title>
      <link href="/2021/12/28/Leetcode2117-Abbreviating-the-Product-of-a-Range/"/>
      <url>/2021/12/28/Leetcode2117-Abbreviating-the-Product-of-a-Range/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-2117-Abbreviating-the-Product-of-a-Range"><a href="#Leetcode-2117-Abbreviating-the-Product-of-a-Range" class="headerlink" title="Leetcode 2117. Abbreviating the Product of a Range"></a>Leetcode 2117. Abbreviating the Product of a Range</h1><h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p>給你兩個正整數left和right，計算閉區間[left, right]中所有整數的<strong>乘積</strong> 。<br>假設res為乘積的結果，C為後綴0的個數。將res去掉0後綴後的剩餘數字記為d。</p><ol><li><p>若d的長度大於十，乘積的表達法如下，pre為d的前五碼，suf為d的後五碼:</p><blockquote><p><code>&quot;&lt;pre&gt;...&lt;suf&gt;eC&quot;</code></p></blockquote></li><li><p>若d的長度在十以內，則乘積的表達法如下，suf就是d:</p><blockquote><p><code>&quot;&lt;suf&gt;eC&quot;</code></p></blockquote></li></ol><p>也就是</p><blockquote><p>12345678987600000被表示為: <code>&quot;12345...89876e5&quot;</code><br>345678987600000被表示為: <code>&quot;3456789876e5&quot;</code></p></blockquote><h2 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h2><ul><li>C: 可以計算2以及5的因數個數，便能事先得到10的個數。</li><li>suf: 剔除10造成的影響後，簡單對10%10取餘數得到</li><li>pre: 大數乘法顯然無法用正常的整數表達，但題目只要維護5個digits，於是我們轉成log10，將乘法運算變成加法運算，最後再還原即可</li></ul><h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> math <span class="token keyword">import</span> log10<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getfactCounts</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 1 ~ n 所有數字累計可以被f整除幾次: n//f + n//(f^2) + n//(f^3) + ...</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> f <span class="token operator">&lt;=</span> n<span class="token punctuation">:</span>            n <span class="token operator">//=</span> f            res <span class="token operator">+=</span> n        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">abbreviateProduct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>        cnt2 <span class="token operator">=</span> self<span class="token punctuation">.</span>getfactCounts<span class="token punctuation">(</span>right<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>getfactCounts<span class="token punctuation">(</span>left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>        cnt5 <span class="token operator">=</span> self<span class="token punctuation">.</span>getfactCounts<span class="token punctuation">(</span>right<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>getfactCounts<span class="token punctuation">(</span>left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>        cnt10 <span class="token operator">=</span> min<span class="token punctuation">(</span>cnt2<span class="token punctuation">,</span> cnt5<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 先得到總共有多少10，等同於知道要消耗多少2和5</span>        use2<span class="token punctuation">,</span> use5 <span class="token operator">=</span> cnt10<span class="token punctuation">,</span> cnt10        frontlog<span class="token punctuation">,</span> suf<span class="token punctuation">,</span> mod <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">**</span><span class="token number">10</span>         <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> use2 <span class="token operator">and</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                use2 <span class="token operator">-=</span> <span class="token number">1</span>                x <span class="token operator">//=</span> <span class="token number">2</span>            <span class="token keyword">while</span> use5 <span class="token operator">and</span> x <span class="token operator">%</span> <span class="token number">5</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                use5 <span class="token operator">-=</span> <span class="token number">1</span>                x <span class="token operator">//=</span> <span class="token number">5</span>            suf <span class="token operator">*=</span> x            frontlog <span class="token operator">+=</span> log10<span class="token punctuation">(</span>x<span class="token punctuation">)</span>            <span class="token keyword">if</span> suf <span class="token operator">></span> mod<span class="token punctuation">:</span>                suf <span class="token operator">=</span> suf <span class="token operator">%</span> mod                <span class="token comment" spellcheck="true"># frontlog - int(frontlog)會變成0.xxxx，10^(0.xxxx)小數點之前只有一位，也就是x.xxxxx</span>        <span class="token comment" spellcheck="true"># 我們想要方便取前5個digits，若求frontlog - int(frontlog) + 4 = 4.xxxx</span>        <span class="token comment" spellcheck="true"># 則10^(4.xxxx)的小數點前有五位，變成xxxxx.xxxx</span>        <span class="token keyword">if</span> frontlog <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> str<span class="token punctuation">(</span>suf<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"e"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>cnt10<span class="token punctuation">)</span>        digit5 <span class="token operator">=</span> str<span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">**</span><span class="token punctuation">(</span>frontlog <span class="token operator">-</span> int<span class="token punctuation">(</span>frontlog<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> digit5 <span class="token operator">+</span> <span class="token string">"..."</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>suf<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"e"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>cnt10<span class="token punctuation">)</span></code></pre><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>上了一課，以後大數乘法且精度要求不高的題目，可以考慮轉成log加法</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Suffix Array</title>
      <link href="/2021/12/28/String-Suffix-Array/"/>
      <url>/2021/12/28/String-Suffix-Array/</url>
      
        <content type="html"><![CDATA[<h1 id="Suffix-Array"><a href="#Suffix-Array" class="headerlink" title="Suffix Array"></a>Suffix Array</h1><p>給一個字串，將這個字串所有的後綴(suffix)都拿出來按照字典序排序，定義</p><ul><li>sa[rank] = idx: 排名在rank的後綴從哪個idx開始</li><li>ranks[idx] = rank: 第idx號後綴的排名為rank</li></ul><p>如下圖，字串為<code>&quot;aabaaaab&quot;</code>，則sa及ranks分別為<br><img src="/images/suffix_array/sa1.jpg" width="70%" height="70%"></p><h2 id="倍增法"><a href="#倍增法" class="headerlink" title="倍增法"></a>倍增法</h2><p>為了更快速的對每個後綴排序，一種簡單的方式是使用倍增法。</p><blockquote><p>在倍增法的第k輪中，我們對每個SubStr(idx, 2^k)做排序，其中:<br><code>SubStr(idx, 2^k) = SubStr(idx, 2^(k-1)) + SubStr(idx+2^(k-1), 2^(k-1))</code></p><p>若我們知道第k-1輪每個SubStr(idx, 2^(k-1))的大小關係，則SubStr(idx,2^k)的大小關係便能透過比較其<code>(ranks[idx], ranks[idx + 2^(k-1)])</code>得到，如下圖。</p></blockquote><img src="/images/suffix_array/sa2.jpg" width="70%" height="70%"><blockquote><p>注意<code>idx+2^(k-1)</code>有可能超過字串範圍，在此將所有超過字串範圍的rank都視為0</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> Longest Duplicate Substring </tag>
            
            <tag> DSA Tutorial String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode Contest Review - Biweekly 68 &amp; Weekly 273</title>
      <link href="/2021/12/27/Leetcode-Contest-Review-Biweekly68-Weekly273/"/>
      <url>/2021/12/27/Leetcode-Contest-Review-Biweekly68-Weekly273/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/LeetcodeIcon.png"></p><h2 id="Leetcode-Biweekly-Contest-68-Review"><a href="#Leetcode-Biweekly-Contest-68-Review" class="headerlink" title="Leetcode Biweekly Contest 68 Review"></a>Leetcode Biweekly Contest 68 Review</h2><h3 id="Q1-LC-2114-Maximum-Number-of-Words-Found-in-Sentences"><a href="#Q1-LC-2114-Maximum-Number-of-Words-Found-in-Sentences" class="headerlink" title="Q1: LC-2114. Maximum Number of Words Found in Sentences"></a>Q1: LC-2114. Maximum Number of Words Found in Sentences</h3><p>比typing速度</p><h3 id="Q2-LC-2115-Find-All-Possible-Recipes-from-Given-Supplies"><a href="#Q2-LC-2115-Find-All-Possible-Recipes-from-Given-Supplies" class="headerlink" title="Q2: LC-2115. Find All Possible Recipes from Given Supplies"></a>Q2: LC-2115. Find All Possible Recipes from Given Supplies</h3><p>這題蠻多英文單字和句子沒看懂，所以一開始亂猜題目，並寫了一個亂猜的版本，浪費了蠻多時間，<strong>如果題目真的不太懂，就更該把測資看完才行</strong>。後來懂了題目後，又花了蠻多時間才意識到是要做topological sort，但如何加速這件事情目前還沒想法，總之這題共花了13分鐘。</p><h3 id="Q3-LC-2116-Check-if-a-Parentheses-String-Can-Be-Valid"><a href="#Q3-LC-2116-Check-if-a-Parentheses-String-Can-Be-Valid" class="headerlink" title="Q3: LC-2116. Check if a Parentheses String Can Be Valid"></a>Q3: LC-2116. Check if a Parentheses String Can Be Valid</h3><p>隨便給一串只包含括號的字串，某些位置被鎖起來不能翻轉，其餘可以自由變換括號方向，問是否存在一個變化方式使字串變成合法的括號形式。<br>其實這題我不太肯定自己的答案是否正確或只是剛好AC，暫時無法明確想到改善方式，需要再多研究一下這題。</p><h3 id="Q4-LC-2117-Abbreviating-the-Product-of-a-Range"><a href="#Q4-LC-2117-Abbreviating-the-Product-of-a-Range" class="headerlink" title="Q4: LC-2117. Abbreviating the Product of a Range"></a>Q4: LC-2117. Abbreviating the Product of a Range</h3><p>將數字變成另一種表達法，這個表達法只會保留前後五碼，並喪失中間所有數字的精度，但題目也只要求前後五碼數字正確即可。</p><p>後五碼的部分應該不會有什麼問題，主要是前五碼，這題我花了兩個多小時才寫出一個前五碼精度不夠正確的答案。<br>題目是將所有數字相乘，後來看到<strong>AC的解是將原始數字取log10後相加，之後再還原即可</strong>，畢竟只要保留前五碼的精度，並不是什麼很嚴苛的條件，真是長知識了</p><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>38分鐘寫前三題加上1次WA：總名次383/10622</p><hr><h2 id="Leetcode-Weekly-Contest-273-Review"><a href="#Leetcode-Weekly-Contest-273-Review" class="headerlink" title="Leetcode Weekly Contest 273 Review"></a>Leetcode Weekly Contest 273 Review</h2><p>這場比賽我只有參加virtual contest，不過跟前一天的比賽相比，真的是簡單很多</p><h3 id="Q1-LC-2119-A-Number-After-a-Double-Reversal"><a href="#Q1-LC-2119-A-Number-After-a-Double-Reversal" class="headerlink" title="Q1: LC-2119. A Number After a Double Reversal"></a>Q1: LC-2119. A Number After a Double Reversal</h3><p>比打字速度的題目，但這題我明顯濫用python數字及字串互轉的方便性，明明只要判斷是否餘十即可。</p><h3 id="Q2-LC-2120-Execution-of-All-Suffix-Instructions-Staying-in-a-Grid"><a href="#Q2-LC-2120-Execution-of-All-Suffix-Instructions-Staying-in-a-Grid" class="headerlink" title="Q2: LC-2120. Execution of All Suffix Instructions Staying in a Grid"></a>Q2: LC-2120. Execution of All Suffix Instructions Staying in a Grid</h3><p>這題原本想了很久，覺得應該有<code>O(n)</code>解，不過最終還是寫了暴力解<code>O(n^2)</code>，另外有一個很爛的bug花了很多時間才找到，他放在我自以為絕對不會出錯的小function上，所以debug途中一直沒有去看那個function。</p><h3 id="Q3-LC-2121-Intervals-Between-Identical-Elements"><a href="#Q3-LC-2121-Intervals-Between-Identical-Elements" class="headerlink" title="Q3: LC-2121. Intervals Between Identical Elements"></a>Q3: LC-2121. Intervals Between Identical Elements</h3><p>我覺得是個好題目，<strong>沿著數線上的點移動，並計算數線上所有點跟這個點的距離和</strong>，雖然不是什麼難題，但我每次遇到都浪費很多時間在實現他，應該要找一個漂亮的版本理解一下。</p><h3 id="Q4-LC-2122-Recover-the-Original-Array"><a href="#Q4-LC-2122-Recover-the-Original-Array" class="headerlink" title="Q4: LC-2122. Recover the Original Array"></a>Q4: LC-2122. Recover the Original Array</h3><p>突破口明顯就是最大或是最小數字，也曾想說有沒有更好的答案，不過顯然暴力解就足以通過，有些一倍delta兩倍delta之類的小細節造成的bug要注意，另外可以再多想想如何輸出解答會更有效。</p><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>是場簡單的比賽，浪費蠻多時間才40分鐘完賽，如果有參加的話應該會落在185/12203上下</p><hr><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul><li>如果題目真的不太懂，就更該把測資看完 (critical)</li><li>英文閱讀能力該提升了，至少要回去把看不懂的問題再多看幾遍 (critical)</li><li>一些不追求精度的問題，可以考慮數值解，例如乘法改成取log10後相加</li><li>沿著數線上的點移動，並<strong>計算數線上所有點跟當前位置的距離和</strong>，遇過這種題目超多次了，每次都寫一個不同版本，快去找一個寫得漂亮的解 (critical)</li><li>有些題目即使無腦解能過，或許簡單想一下實作起來更簡單</li><li>寫程式時，大方向把握後，就該注意小細節別寫錯</li></ul>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Competitive Programming </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Leetcode Contest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode Contest Review - Weekly 272</title>
      <link href="/2021/12/19/Leetcode-Contest-Review-Weekly272/"/>
      <url>/2021/12/19/Leetcode-Contest-Review-Weekly272/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/LeetcodeIcon.png"></p><h2 id="Leetcode-Weekly-Contest-272-Review"><a href="#Leetcode-Weekly-Contest-272-Review" class="headerlink" title="Leetcode Weekly Contest 272 Review"></a>Leetcode Weekly Contest 272 Review</h2><p>這場比賽實在太簡單，13分鐘完賽排全球51名，雖然成就感十足，但有時候不禁讓人覺得打LC Contest是浪費時間。想想昨天有一場Codeforce比賽沒去參加真的是比較可惜了。</p><h3 id="Q1-Find-First-Palindromic-String-in-the-Array"><a href="#Q1-Find-First-Palindromic-String-in-the-Array" class="headerlink" title="Q1: Find First Palindromic String in the Array"></a>Q1: Find First Palindromic String in the Array</h3><p>秒解</p><h3 id="Q2-Adding-Spaces-to-a-String"><a href="#Q2-Adding-Spaces-to-a-String" class="headerlink" title="Q2: Adding Spaces to a String"></a>Q2: Adding Spaces to a String</h3><p>這場最失敗的一題，我看到要push空白字符到string，怕用python的字串相加(<code>str + str</code>)會導致複雜度變成n^2，竟然一時之間腦袋當機改成用C++寫，python明明隨便開個list放資料最後再join就好。偏偏C++又不太熟，多花了一點時間在想語法，共花了四分鐘。</p><p>值得一提的是，我顯然沒仔細注意spaces的範圍，所以多寫了幾行無意義的邊界判斷，雖然這次沒出錯，但真的該慎記題目要看仔細…</p><h3 id="Q3-Number-of-Smooth-Descent-Periods-of-a-Stock"><a href="#Q3-Number-of-Smooth-Descent-Periods-of-a-Stock" class="headerlink" title="Q3: Number of Smooth Descent Periods of a Stock"></a>Q3: Number of Smooth Descent Periods of a Stock</h3><p>有除過一次bug是沒注意每個價格要剛好遞減1，當時以為只需要遞減。也是題目沒看仔細的緣故…</p><h3 id="Q4-Minimum-Operations-to-Make-the-Array-K-Increasing"><a href="#Q4-Minimum-Operations-to-Make-the-Array-K-Increasing" class="headerlink" title="Q4: Minimum Operations to Make the Array K-Increasing"></a>Q4: Minimum Operations to Make the Array K-Increasing</h3><p>這題第一次掃過題目時沒有完全看懂重點是什麼，後來看到測資二才明白根本就是LIS，這題主要卡在英文比大多數參賽者弱，希望能再提升。<br>另外發現有些rating蠻高的台灣人竟然不知道有nlogn的LIS，真是替他們可惜</p><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>13分鐘完賽：總名次51/15426</p><hr><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ul><li><font color="LightSalmon" size=5><strong>題目真的真的真的要看仔細</strong></font></li><li>需要提升英文閱讀的精度和速度</li></ul>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Competitive Programming </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Leetcode Contest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DSU On Tree (樹上啟發式合併)</title>
      <link href="/2021/12/18/Graph-Dsu-On-Tree/"/>
      <url>/2021/12/18/Graph-Dsu-On-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="樹上啟發式合併"><a href="#樹上啟發式合併" class="headerlink" title="樹上啟發式合併"></a>樹上啟發式合併</h1><blockquote><p>In Iran, we call this technique “Guni” (the word means “Sack” in English), instead of “dsu on tree”</p></blockquote><p>對於兩個大小不一樣的集合，我們將小的集合合併到大的集合中，而不是將大的集合合併到小的集合中。</p><h2 id="理解輕重兒子以及輕重邊"><a href="#理解輕重兒子以及輕重邊" class="headerlink" title="理解輕重兒子以及輕重邊"></a>理解輕重兒子以及輕重邊</h2><p>每個節點之下，都有若干兒子子樹，定義<strong>重兒子</strong>為擁有最多節點的兒子子樹，其餘就是輕兒子。同理，重邊就是連接重兒子的邊，其餘就是輕邊</p><p>下圖，紅節點就是重兒子，黑粗邊就是重邊</p><p><img src="/images/dsu_on_tree/img1.png" alt="輕重兒子及輕重邊"></p><h2 id="作法"><a href="#作法" class="headerlink" title="作法"></a>作法</h2><p><a href="https://cses.fi/problemset/task/1139/">CSES: Distinct Colors</a></p><p>在一棵樹上為每個節點上色，對以每個節點為根的樹，都詢問內含多少種顏色。顯然窮舉法是O(n^2)</p><blockquote><p>若我們能先透過前處理將每個輕重兒子區分出來，並在窮舉的過程，在每個節點採用下面策略</p><ol><li>先各自統計所有輕兒子的顏色，<strong>不保留結果</strong></li><li>統計重兒子的顏色，<strong>並保留結果</strong></li><li>重新掃過所有輕兒子，<strong>並將結果累加到重兒子的結果上</strong>，便能得到當前節點的顏色</li></ol></blockquote><h2 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h2><blockquote><ol><li><p>步驟1和2其實就是遍歷每個點一次。</p></li><li><p><strong>根結點到任意節點，經過的輕邊必然不超過log(n)條</strong>。</p></li><li><p>除此之外每個點都還會被若干次步驟3經過，而每個點被步驟3經過的次數，其實就是這個點<strong>往根方向經過的輕邊總數</strong>。</p></li><li><p>因此每個點最多被經過1 + log(n)次，總合為n*(1 + log(n)) = <code>O(n*log(n))</code></p></li></ol></blockquote><h2 id="程式碼1"><a href="#程式碼1" class="headerlink" title="程式碼1"></a>程式碼1</h2><p>最標準的啟發式合併，但是有一個測資會TLE，雖然空間複雜度是O(n)，但是整體複雜很多。</p><ul><li>時間複雜度：<code>O(n*log(n))</code></li><li>空間複雜度：<code>O(n)</code></li></ul><blockquote><p>原本我不是自己維護counter，而是使用 unordered_set去記錄顏色的數量，不過在測資10一直TLE。改成自己維護counter之後，不但通過了，總花費時間還只有版本二的60%左右</p><p>結論是在考慮效能下，<strong>能使用陣列就盡量就別用雜湊表</strong></p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// cses1139_distinct_colors.cpp</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/extc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">using</span> ll <span class="token operator">=</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token keyword">using</span> pii <span class="token operator">=</span> pair<span class="token operator">&lt;</span>ll<span class="token punctuation">,</span> ll<span class="token operator">></span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> AC ios::sync_with_stdio(0),cin.tie(0);</span> ll <span class="token keyword">const</span> MOD <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>ll <span class="token keyword">const</span> LL_MAX <span class="token operator">=</span> <span class="token number">1e18</span> <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>ll <span class="token keyword">const</span> N <span class="token operator">=</span> <span class="token number">200005</span><span class="token punctuation">;</span>ll <span class="token keyword">const</span> BLEN <span class="token operator">=</span> <span class="token function">__lg</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">struct</span> custom_hash <span class="token punctuation">{</span>    <span class="token keyword">static</span> uint64_t <span class="token function">splitmix64</span><span class="token punctuation">(</span>uint64_t x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// http://xorshift.di.unimi.it/splitmix64.c</span>        x <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">0x9e3779b97f4a7c15</span><span class="token punctuation">;</span>        x <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">^</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0xbf58476d1ce4e5b9</span><span class="token punctuation">;</span>        x <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">^</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0x94d049bb133111eb</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x <span class="token operator">^</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>uint64_t x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">static</span> <span class="token keyword">const</span> uint64_t FIXED_RANDOM <span class="token operator">=</span> chrono<span class="token operator">::</span>steady_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">time_since_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">splitmix64</span><span class="token punctuation">(</span>x <span class="token operator">+</span> FIXED_RANDOM<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> adj<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// adjacent matrix</span><span class="token keyword">int</span> ans<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// answer</span><span class="token keyword">int</span> dfn<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// dfs order of each node</span><span class="token keyword">int</span> big<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// big child of each node</span><span class="token keyword">int</span> L<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// first idx of dfs order starting from node</span><span class="token keyword">int</span> R<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// last idx of dfs order starting from node</span><span class="token keyword">int</span> colors<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// color of each node</span><span class="token keyword">int</span> node_size<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// size of each tree starting from node</span><span class="token keyword">int</span> counter<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> timestamp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">pre_dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 1. mark dfn     * 2. count size of tree with root node     * 3. find big child of the current node      * 4. dfs order starting from the current node (L[node] ~ R[node])     */</span>    dfn<span class="token punctuation">[</span><span class="token operator">++</span>timestamp<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">;</span>    L<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> timestamp<span class="token punctuation">;</span>    node_size<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> nxt <span class="token operator">:</span> adj<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nxt <span class="token operator">==</span> parent<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token function">pre_dfs</span><span class="token punctuation">(</span>nxt<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>        node_size<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> node_size<span class="token punctuation">[</span>nxt<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>big<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">||</span> node_size<span class="token punctuation">[</span>big<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> node_size<span class="token punctuation">[</span>nxt<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            big<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> nxt<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    R<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> timestamp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> parent<span class="token punctuation">,</span> <span class="token keyword">bool</span> keep<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1. traversal light childrens</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> nxt <span class="token operator">:</span> adj<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nxt <span class="token operator">==</span> parent <span class="token operator">||</span> nxt <span class="token operator">==</span> big<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>nxt<span class="token punctuation">,</span> node<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 2. traversal big child, and kepp current</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>big<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>big<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">,</span> node<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 3. sum up light sub-trees into current</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> nxt <span class="token operator">:</span> adj<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nxt <span class="token operator">==</span> parent <span class="token operator">||</span> nxt <span class="token operator">==</span> big<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> t <span class="token operator">=</span> L<span class="token punctuation">[</span>nxt<span class="token punctuation">]</span><span class="token punctuation">;</span> t <span class="token operator">&lt;=</span> R<span class="token punctuation">[</span>nxt<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>colors<span class="token punctuation">[</span>dfn<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> total<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>colors<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> total<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// remove counter if keep is false</span>    ans<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> total<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>keep<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> t <span class="token operator">=</span> L<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">;</span> t <span class="token operator">&lt;=</span> R<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            counter<span class="token punctuation">[</span>colors<span class="token punctuation">[</span>dfn<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> custom_hash<span class="token operator">></span> color2idx<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cin <span class="token operator">>></span> x<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>color2idx<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> color2idx<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span>        colors<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> color2idx<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cin <span class="token operator">>></span> a <span class="token operator">>></span> b<span class="token punctuation">;</span>        adj<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        adj<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pre_dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    AC    <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="程式碼2"><a href="#程式碼2" class="headerlink" title="程式碼2"></a>程式碼2</h2><p>對每個節點都儲存所有顏色，由於顏色數量不會超過節點數，若合併至母節點時，總是小的往大集合合併，總時空間複雜度應為n*log(n)</p><ul><li>時間複雜度：<code>O(n*log(n))</code></li><li>空間複雜度：<code>O(n*log(n))</code></li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// cses1139_distinct_colors.cpp</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/extc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">using</span> ll <span class="token operator">=</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token keyword">using</span> pii <span class="token operator">=</span> pair<span class="token operator">&lt;</span>ll<span class="token punctuation">,</span> ll<span class="token operator">></span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> AC ios::sync_with_stdio(0),cin.tie(0);</span> ll <span class="token keyword">const</span> MOD <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>ll <span class="token keyword">const</span> LL_MAX <span class="token operator">=</span> <span class="token number">1e18</span> <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>ll <span class="token keyword">const</span> N <span class="token operator">=</span> <span class="token number">200005</span><span class="token punctuation">;</span>ll <span class="token keyword">const</span> BLEN <span class="token operator">=</span> <span class="token function">__lg</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">struct</span> custom_hash <span class="token punctuation">{</span>    <span class="token keyword">static</span> uint64_t <span class="token function">splitmix64</span><span class="token punctuation">(</span>uint64_t x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// http://xorshift.di.unimi.it/splitmix64.c</span>        x <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">0x9e3779b97f4a7c15</span><span class="token punctuation">;</span>        x <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">^</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0xbf58476d1ce4e5b9</span><span class="token punctuation">;</span>        x <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">^</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0x94d049bb133111eb</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x <span class="token operator">^</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>uint64_t x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">static</span> <span class="token keyword">const</span> uint64_t FIXED_RANDOM <span class="token operator">=</span> chrono<span class="token operator">::</span>steady_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">time_since_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">splitmix64</span><span class="token punctuation">(</span>x <span class="token operator">+</span> FIXED_RANDOM<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> adj<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> ans<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> custom_hash<span class="token operator">></span> colors<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span> pre<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> nxt <span class="token operator">:</span> adj<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nxt <span class="token operator">==</span> pre<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>nxt<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>colors<span class="token punctuation">[</span>nxt<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> colors<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>colors<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> colors<span class="token punctuation">[</span>nxt<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                colors<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>colors<span class="token punctuation">[</span>nxt<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> colors<span class="token punctuation">[</span>nxt<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ans<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> colors<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> x<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cin <span class="token operator">>></span> x<span class="token punctuation">;</span>        colors<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cin <span class="token operator">>></span> a <span class="token operator">>></span> b<span class="token punctuation">;</span>        adj<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        adj<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    AC    <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.cnblogs.com/EinNiemand/p/11721101.html#%E5%BA%94%E7%94%A8%E7%AF%87%E5%90%84%E7%A7%8D%E7%81%B5%E6%B4%BB%E8%BF%90%E7%94%A8">dsu on tree学习笔记</a></li><li><a href="https://codeforces.com/blog/entry/44351">Codeforce: [Tutorial] Sack (dsu on tree)</a></li><li><a href="https://oi-wiki.org/graph/dsu-on-tree/">OI-Wiki: 树上启发式合并</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graph </tag>
            
            <tag> DSA Tutorial Graph </tag>
            
            <tag> DSU On Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Minimum Height Trees (MHTs)</title>
      <link href="/2021/12/17/Graph-Minimum-Height-Trees/"/>
      <url>/2021/12/17/Graph-Minimum-Height-Trees/</url>
      
        <content type="html"><![CDATA[<h1 id="Minimum-Height-Trees-MHTs"><a href="#Minimum-Height-Trees-MHTs" class="headerlink" title="Minimum Height Trees (MHTs)"></a>Minimum Height Trees (MHTs)</h1><p>從樹中找到一個或若干根結點，使<strong>所有子樹的最大深度最小</strong>。</p><h2 id="解說"><a href="#解說" class="headerlink" title="解說"></a>解說</h2><p>跟尋找樹重心不同，最大深度問題不能採用dfs的原因在於：即使能判定其母節點方向的節點數有多少，依然無法確定母節點方向的最大深度。</p><p>此時可以換個方式思考，假設我將每個<strong>葉節點</strong>(<code>只有一個edge接觸的點</code>)都從樹中移除。此時若樹中還有未被選到的點，代表這輪挑選到的葉節點必然不會是根，因此我們重新在當前的樹內重新挑選一次葉節點。</p><blockquote><p>實作方法相似拓樸排序，但<strong>注意葉節點的degree是1而不是0</strong></p></blockquote><h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token punctuation">,</span> Counter<span class="token punctuation">,</span> deque    <span class="token keyword">def</span> <span class="token function">find_mht_roots</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> edges<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""find all roots of MHTs    - n: n nodes labelled from 0 to n - 1    - edges: list of bidirectional edge where edges[i] = [a_i, b_i]    """</span>    <span class="token comment" spellcheck="true"># </span>    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    adj <span class="token operator">=</span> collections<span class="token punctuation">.</span>defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span>    degrees <span class="token operator">=</span> collections<span class="token punctuation">.</span>Counter<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> x<span class="token punctuation">,</span> y <span class="token keyword">in</span> edges<span class="token punctuation">:</span>        degrees<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        degrees<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        adj<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>y<span class="token punctuation">)</span>        adj<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    queue <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> x <span class="token keyword">in</span> degrees<span class="token punctuation">:</span>        <span class="token keyword">if</span> degrees<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    res <span class="token operator">=</span> list<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> queue<span class="token punctuation">:</span>        res <span class="token operator">=</span> list<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>        queue<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> x <span class="token keyword">in</span> res<span class="token punctuation">:</span>            <span class="token keyword">for</span> y <span class="token keyword">in</span> adj<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">:</span>                degrees<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">if</span> degrees<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#等於1就是找到葉節點</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>y<span class="token punctuation">)</span>    <span class="token keyword">return</span> res</code></pre><h2 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h2><ul><li>時間複雜度：<code>O(V + E)</code></li><li>空間複雜度：<code>O(V + E)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graph </tag>
            
            <tag> DSA Tutorial Graph </tag>
            
            <tag> Minimum Height Trees </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Useful Commands</title>
      <link href="/2021/12/16/Git-Useful-Commands/"/>
      <url>/2021/12/16/Git-Useful-Commands/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>Git is a version control system on a machine locally.</p><h2 id="Necessary-Git-Commands"><a href="#Necessary-Git-Commands" class="headerlink" title="Necessary Git Commands"></a>Necessary Git Commands</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> init<span class="token function">git</span> status<span class="token function">git</span> log<span class="token function">git</span> log --oneline<span class="token function">git</span> push<span class="token function">git</span> push -f <span class="token comment" spellcheck="true"># force push</span><span class="token function">git</span> branch <span class="token string">"branch_name"</span><span class="token function">git</span> branch -d <span class="token string">"branch_name"</span> <span class="token comment" spellcheck="true"># delete</span><span class="token function">git</span> branch -M <span class="token string">"new name"</span> <span class="token comment" spellcheck="true"># rename current branch</span><span class="token function">git</span> switch <span class="token string">"branch_name"</span><span class="token function">git</span> switch - <span class="token comment" spellcheck="true"># back to whatever branch I was</span><span class="token function">git</span> switch -c <span class="token string">"branch_name"</span> <span class="token comment" spellcheck="true"># create a branch and switch to it</span><span class="token function">git</span> checkout -b <span class="token string">"branch_name"</span> <span class="token comment" spellcheck="true"># create a branch and switch to it</span><span class="token function">git</span> add file1, file2, file3<span class="token function">git</span> add <span class="token keyword">.</span><span class="token function">git</span> commit<span class="token function">git</span> commit -m <span class="token string">"message of this commit"</span><span class="token function">git</span> commit -am <span class="token string">"message of this commit"</span> <span class="token comment" spellcheck="true"># add all and commit with msg</span><span class="token function">git</span> commit --amend <span class="token comment" spellcheck="true"># modify the most recent commit</span><span class="token function">git</span> merge<span class="token comment" spellcheck="true"># - Fast Forward Merge</span><span class="token comment" spellcheck="true"># - Merge Commit</span><span class="token comment" spellcheck="true"># - CONNFLICT</span><span class="token comment" spellcheck="true">#     - (0) git merge --abort</span><span class="token comment" spellcheck="true">#     - 1. git status to find unmerged files</span><span class="token comment" spellcheck="true">#     - 2. edit files and remove conflict "markers"</span><span class="token comment" spellcheck="true">#     - 3. git add &lt;file></span><span class="token comment" spellcheck="true">#     - 4. git commit</span></code></pre><h2 id="Useful-Git-Commands"><a href="#Useful-Git-Commands" class="headerlink" title="Useful Git Commands"></a>Useful Git Commands</h2><h3 id="Git-Diff"><a href="#Git-Diff" class="headerlink" title="Git Diff"></a>Git Diff</h3><blockquote><p>to view changes between commits, branches, files, working directory, …</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># @@ -1,6 +1,8 @@: Chunk Header</span><span class="token comment" spellcheck="true">#    1. 舊版本，從第1行開始連續6行</span><span class="token comment" spellcheck="true">#    2. 新版本，從第1行開始連續8行</span><span class="token comment" spellcheck="true"># 1. 當工作區有改動，暫存區為空，diff的對比是“工作區與最後一次commit提交的倉庫的「共同文件」”</span><span class="token comment" spellcheck="true"># 2. 當工作區有改動，暫存區不為空，diff對比的是“工作區與暫存區的共同文件”。</span><span class="token function">git</span> <span class="token function">diff</span><span class="token comment" spellcheck="true"># 工作區和暫存區與最後一次commit(HEAD)之間的變動</span><span class="token function">git</span> <span class="token function">diff</span> HEAD<span class="token comment" spellcheck="true"># 顯示暫存區(staged)和最後一次commit(HEAD)之間的所有不相同文件的增刪改</span><span class="token function">git</span> <span class="token function">diff</span> --staged<span class="token function">git</span> <span class="token function">diff</span> --cached<span class="token function">git</span> <span class="token function">diff</span> HEAD <span class="token punctuation">[</span>filename<span class="token punctuation">]</span><span class="token function">git</span> <span class="token function">diff</span> --staged <span class="token punctuation">[</span>filename<span class="token punctuation">]</span><span class="token function">git</span> <span class="token function">diff</span> branch1<span class="token punctuation">..</span>branch2<span class="token function">git</span> <span class="token function">diff</span> commit1<span class="token punctuation">..</span>commit2</code></pre><h3 id="Git-Stash"><a href="#Git-Stash" class="headerlink" title="Git Stash"></a>Git Stash</h3><blockquote><p>Git provides an easy way of stashing these uncommitted changes so that we can return to them later, without having to make unnecessary commits.</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># stash all uncommitted changes</span><span class="token function">git</span> stash<span class="token function">git</span> stash save<span class="token comment" spellcheck="true"># stashed changes are restored</span><span class="token function">git</span> stash pop<span class="token comment" spellcheck="true"># apply whatever is stashed away</span><span class="token comment" spellcheck="true"># It can be useful if you want to apply stashed changes to multiple branches</span><span class="token function">git</span> stash apply <span class="token comment" spellcheck="true"># 在不同branch apply，可能要解conflict</span><span class="token function">git</span> stash apply stash@<span class="token punctuation">{</span>2<span class="token punctuation">}</span> <span class="token comment" spellcheck="true"># apply particular one</span><span class="token function">git</span> stash list <span class="token comment" spellcheck="true"># show stash list</span><span class="token function">git</span> stash drop <span class="token comment" spellcheck="true"># drop top stashed changes only</span><span class="token function">git</span> stash drop stash@<span class="token punctuation">{</span>3<span class="token punctuation">}</span> <span class="token comment" spellcheck="true"># drop particular one</span><span class="token function">git</span> stash <span class="token function">clear</span> <span class="token comment" spellcheck="true"># clear all stashed changes</span></code></pre><h3 id="Undo-changes-Go-back-in-time"><a href="#Undo-changes-Go-back-in-time" class="headerlink" title="Undo changes, Go back in time"></a>Undo changes, Go back in time</h3><h4 id="Detached-HEAD"><a href="#Detached-HEAD" class="headerlink" title="Detached HEAD"></a>Detached HEAD</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># checkout 功能太多，才衍生 switch, restore</span><span class="token function">git</span> checkout <span class="token operator">&lt;</span>commit-hash<span class="token operator">></span> <span class="token comment" spellcheck="true"># view a previous commit</span><span class="token comment" spellcheck="true"># 1. Usually, HEAD points to a specific branch reference rather than a particular commit. When we checkout a particular commit, HEAD points at that commit rather than at the branch pointer (detached head)</span><span class="token comment" spellcheck="true"># 2. Levae by using git switch &lt;branch-name></span><span class="token comment" spellcheck="true"># 3. Create a new branch and switch to it. (new branch is based upon HEAD)</span><span class="token function">git</span> checkout HEAD~2 <span class="token comment" spellcheck="true"># refers to 2 commits before this HEAD</span></code></pre><h4 id="Discarding-Changes"><a href="#Discarding-Changes" class="headerlink" title="Discarding Changes"></a>Discarding Changes</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout HEAD <span class="token operator">&lt;</span>filename<span class="token operator">></span> <span class="token comment" spellcheck="true"># to discard any changes in that file, reverting back to the HEAD</span><span class="token function">git</span> checkout -- <span class="token operator">&lt;</span>filename<span class="token operator">></span><span class="token function">git</span> restore <span class="token operator">&lt;</span>filename1, filename2, <span class="token punctuation">..</span>.<span class="token operator">></span> <span class="token comment" spellcheck="true"># to restore the file to the contents in the HEAD</span><span class="token function">git</span> restore --source HEAD~1 <span class="token operator">&lt;</span>filename<span class="token operator">></span> <span class="token comment" spellcheck="true"># to restore the contents to its state from the commit prior to HEAD</span><span class="token function">git</span> restore --source <span class="token operator">&lt;</span>commit-hash<span class="token operator">></span> <span class="token operator">&lt;</span>filename<span class="token operator">></span><span class="token function">git</span> restore --staged <span class="token operator">&lt;</span>filename<span class="token operator">></span> <span class="token comment" spellcheck="true"># remove file from staging area, but it is still in the working area.</span><span class="token function">git</span> reset <span class="token operator">&lt;</span>commit-hash<span class="token operator">></span> <span class="token comment" spellcheck="true"># will reset the repo back to a specific commit, the commits are gone, but the changes are still in the working area</span><span class="token function">git</span> reset --hard <span class="token operator">&lt;</span>commit-hash<span class="token operator">></span> <span class="token comment" spellcheck="true"># will delete the alst commit as well as associated changes</span><span class="token comment" spellcheck="true"># 1. reset removes commits entirely and it moves the branch pointer backwards if those commits nevers occurred</span><span class="token comment" spellcheck="true"># 2. revert creates a new commit which undo changes from a commit, revert may also cause CONFLICT</span><span class="token function">git</span> revert <span class="token operator">&lt;</span>commit-hash<span class="token operator">></span><span class="token comment" spellcheck="true"># 使用revert而不是reset的時機：假設有一些bad commit要移除，但是在多人合作模式下，若這些commit正在被其他人使用中，我不能直接透過reset移除這些commit，這樣之後merge會有問題，那為了把過去的錯誤消除，我們能透過revert創立新的commit去移除這些問題。</span></code></pre><h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><p>Github is a hosting platform for git repositories</p><h2 id="Necessary-Commands"><a href="#Necessary-Commands" class="headerlink" title="Necessary Commands"></a>Necessary Commands</h2><h3 id="Setting"><a href="#Setting" class="headerlink" title="Setting"></a>Setting</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone <span class="token operator">&lt;</span>URL<span class="token operator">></span> <span class="token comment" spellcheck="true"># URL並不是綁github的連結</span><span class="token function">git</span> config user.email <span class="token string">"mail"</span><span class="token function">git</span> config user.password <span class="token string">""</span><span class="token comment" spellcheck="true"># SSH Keys: need to be authenticated on Github to do certain operations</span><span class="token comment" spellcheck="true"># 1. check whether ssh key exists: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys</span><span class="token comment" spellcheck="true"># 2. generate a new ssh key: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</span></code></pre><h3 id="Remote"><a href="#Remote" class="headerlink" title="Remote"></a>Remote</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> remote -v <span class="token comment" spellcheck="true"># show url of fetch, push</span><span class="token function">git</span> remote <span class="token comment" spellcheck="true"># origin</span><span class="token comment" spellcheck="true"># EXIST LOCAL REPO</span><span class="token comment" spellcheck="true"># 1. Create a new repo on Github</span><span class="token comment" spellcheck="true"># 2. Connect your local repo (add a remote)</span><span class="token comment" spellcheck="true"># 3. Push up your changes to Github</span><span class="token function">git</span> remote <span class="token operator">&lt;</span>name<span class="token operator">></span> <span class="token operator">&lt;</span>url<span class="token operator">></span> <span class="token comment" spellcheck="true"># git remote origin https://github.com/...., connect the local repo to a url</span><span class="token function">git</span> remote <span class="token function">rename</span> <span class="token operator">&lt;</span>oldname<span class="token operator">></span> <span class="token operator">&lt;</span>newname<span class="token operator">></span><span class="token function">git</span> remote remove <span class="token operator">&lt;</span>name<span class="token operator">></span><span class="token comment" spellcheck="true"># START FROM SCARTCH</span><span class="token comment" spellcheck="true"># 1. Create a brand new repo on Github</span><span class="token comment" spellcheck="true"># 2. Clone it down to your machine</span><span class="token comment" spellcheck="true"># 3. Do some work locally</span><span class="token comment" spellcheck="true"># 4. Push up your changes to Github</span></code></pre><h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> push <span class="token comment" spellcheck="true"># 會提交到"預設"的儲存庫</span><span class="token function">git</span> push <span class="token operator">&lt;</span>remote<span class="token operator">></span> <span class="token operator">&lt;</span>branch<span class="token operator">></span> <span class="token comment" spellcheck="true"># `git push origin master`, push up the master branch to our origin remote</span><span class="token function">git</span> push <span class="token operator">&lt;</span>remote<span class="token operator">></span> <span class="token operator">&lt;</span>local-branch<span class="token operator">></span>:<span class="token operator">&lt;</span>remote-branch<span class="token operator">></span> <span class="token comment" spellcheck="true"># push local branch into remote branch</span><span class="token function">git</span> push origin --delete <span class="token operator">&lt;</span>remote-branch<span class="token operator">></span> <span class="token comment" spellcheck="true"># delete remote branch</span><span class="token function">git</span> push origin -d <span class="token operator">&lt;</span>remote-branch<span class="token operator">></span><span class="token function">git</span> push -u origin master <span class="token comment" spellcheck="true"># -u 表示將origin/master設定為本地master分支的upstream</span><span class="token function">git</span> push -u origin <span class="token operator">&lt;</span>local-branch<span class="token operator">></span>:<span class="token operator">&lt;</span>remote-branch<span class="token operator">></span></code></pre><h3 id="Pull-amp-Fetch"><a href="#Pull-amp-Fetch" class="headerlink" title="Pull &amp; Fetch"></a>Pull &amp; Fetch</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#當本地branch跟remote的branch不同時，也能checkout remote branch</span><span class="token function">git</span> checkout origin/main<span class="token comment" spellcheck="true"># 當我們clone一個repo下來，master之外的其他branches並不會被載下來</span><span class="token function">git</span> branch <span class="token comment" spellcheck="true"># 此時local看不到其他branch</span><span class="token function">git</span> branch -r <span class="token comment" spellcheck="true"># 看的到remote的branch</span><span class="token function">git</span> switch <span class="token operator">&lt;</span>remote-branch-name<span class="token operator">></span> <span class="token comment" spellcheck="true">#就能直接track remote branch到local</span><span class="token function">git</span> checkout --track origin/<span class="token operator">&lt;</span>remote-branch-name<span class="token operator">></span> <span class="token comment" spellcheck="true">#舊版的方式去track remoet branch</span><span class="token comment" spellcheck="true"># fetching allow us to download all changes from the origin remote repo, BUT those changes will not be auto integrated into working files</span><span class="token comment" spellcheck="true"># 注意fetch並不會讓local working area的檔案被修改，只是更新存在本地端的&lt;remote>/&lt;branch>資訊</span><span class="token function">git</span> fetch <span class="token operator">&lt;</span>remote<span class="token operator">></span> <span class="token comment" spellcheck="true"># fetch all changes from remote, 包含新建的branch</span><span class="token function">git</span> fetch<span class="token function">git</span> fetch origin <span class="token function">git</span> fetch <span class="token operator">&lt;</span>remote<span class="token operator">></span> <span class="token operator">&lt;</span>remote-branch<span class="token operator">></span><span class="token comment" spellcheck="true"># pulling will go and download data from Github AND immediately update my local repo with those changes.</span><span class="token comment" spellcheck="true"># git pull = git fetch + git merge</span><span class="token comment" spellcheck="true"># May cause Merge Conflict</span><span class="token function">git</span> pull <span class="token operator">&lt;</span>remote<span class="token operator">></span> <span class="token operator">&lt;</span>branch<span class="token operator">></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Disjoint Set Union (DSU)</title>
      <link href="/2021/12/16/Graph-Disjoint-Set/"/>
      <url>/2021/12/16/Graph-Disjoint-Set/</url>
      
        <content type="html"><![CDATA[<h1 id="Disjoint-Set-Union-DSU"><a href="#Disjoint-Set-Union-DSU" class="headerlink" title="Disjoint Set Union (DSU)"></a>Disjoint Set Union (DSU)</h1><p><strong>並查集</strong>英文名為Disjoint Set Union)又被稱為Union Find，因為兩個最主要的函式分別就是Union和Find</p><h2 id="Use-Case"><a href="#Use-Case" class="headerlink" title="Use Case"></a>Use Case</h2><p>最常用來檢驗Graph中兩個節點是否連通</p><h2 id="Naive-implementation"><a href="#Naive-implementation" class="headerlink" title="Naive implementation"></a>Naive implementation</h2><p>主要的做法就是透過parents的機制搜索樹的root，將有同樣root的節點視為在同一個連通塊中。</p><blockquote><p>初始化會將所有節點的parent都指到結點自己</p><ul><li><strong>Find(node)</strong>: 沿著parent找到node的root</li><li><strong>Union(node1, node2)</strong>: 連接包含node1的樹以及包含node2的樹<ul><li>具體作法是先各自找到root1以及root2</li><li>再將兩棵樹接起來，接起來的方式就是將其中一個root的parent指到另一個</li></ul></li></ul></blockquote><p>如下圖<br><img src="/images/dsu/dsu1.png" alt="Disjoint Set Union"></p><h2 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h2><h3 id="Path-Compression"><a href="#Path-Compression" class="headerlink" title="Path Compression"></a>Path Compression</h3><p>有些使用情境中，我們只想簡單使用Union以及Find，而且不在意同一棵樹除了根之外如何連通，就能考慮在Find裡面使用Path Compression。</p><blockquote><p>由於在同一棵樹裡面，我們只在意根固定，因此在搜索根的過程中，便能順便改變樹的結構，將所有路過的節點的parent指到根，這樣能很大程度降低樹的深度</p></blockquote><p>如下圖<br><img src="/images/dsu/dsu2.png" alt="Disjoint Set Union"></p><blockquote><p>This simple modification of the operation already achieves the time complexity <strong><code>O(logn)</code> per call</strong> on average</p></blockquote><h3 id="Union-by-Rank-Size"><a href="#Union-by-Rank-Size" class="headerlink" title="Union by Rank / Size"></a>Union by Rank / Size</h3><p>Union的操作是在兩棵樹中，將其中一個樹的根結點的parent指向另一個樹的根節點。此時我們應該要考量，哪一個根結點作為兩顆樹合併後的根結點是更為合適的？</p><p>基於不同考量，一般有兩種合併樹的方式：</p><ul><li><font color="LightSalmon" size=5><strong>Union by Rank</strong></font>：我們希望<strong>最大深度</strong>在合併之後的變化越少越好，明顯的我們將深度比較小的樹指到深度深的。這樣在最糟情況下，最大深度頂多比原本的多1而已<br><img src="/images/dsu/dsu4.png" alt="Union by Rank"></li></ul><ul><li><font color="LightSalmon" size=5><strong>Union by Size</strong></font>：我們希望<strong>節點數</strong>的變化越少越好，顯然節點少的樹指到節點多的樹，會是更有利的變化<br><img src="/images/dsu/dsu3.png" alt="Union by Size"></li></ul><h2 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h2><blockquote><p>若同時包含<strong>path compression</strong>和<strong>union by size / rank</strong>: <code>constant time</code> per queries.</p></blockquote><blockquote><p>若只包含<strong>union by size / rank</strong>: <code>O(n*logn)</code> per queries</p></blockquote><h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">UF</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>parents <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>rank <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>n <span class="token operator">=</span> n            <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># with path compression</span>        <span class="token keyword">if</span> idx <span class="token operator">!=</span> self<span class="token punctuation">.</span>parents<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>parents<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>self<span class="token punctuation">.</span>parents<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>parents<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">naive_find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> idx <span class="token operator">==</span> self<span class="token punctuation">.</span>parents<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> idx        <span class="token keyword">return</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>self<span class="token punctuation">.</span>parents<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">naive_union</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> idx1<span class="token punctuation">,</span> idx2<span class="token punctuation">)</span><span class="token punctuation">:</span>        p1 <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>idx1<span class="token punctuation">)</span>        p2 <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>idx2<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>parents<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">=</span> p1        <span class="token keyword">def</span> <span class="token function">union_by_rank</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> idx1<span class="token punctuation">,</span> idx2<span class="token punctuation">)</span><span class="token punctuation">:</span>        p1 <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>idx1<span class="token punctuation">)</span>        p2 <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>idx2<span class="token punctuation">)</span>        <span class="token keyword">if</span> p1 <span class="token operator">!=</span> p2<span class="token punctuation">:</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>rank<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>rank<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">:</span>                p1<span class="token punctuation">,</span> p2 <span class="token operator">=</span> p2<span class="token punctuation">,</span> p1            self<span class="token punctuation">.</span>parents<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">=</span> p1            <span class="token comment" spellcheck="true"># if rank of p1 and p2 are the same -> max height + 1 after merge</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>rank<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>rank<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>rank<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">union_by_size</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> idx1<span class="token punctuation">,</span> idx2<span class="token punctuation">)</span><span class="token punctuation">:</span>        p1 <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>idx1<span class="token punctuation">)</span>        p2 <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>idx2<span class="token punctuation">)</span>        <span class="token keyword">if</span> p1 <span class="token operator">!=</span> p2<span class="token punctuation">:</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>size<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>size<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">:</span>                p1<span class="token punctuation">,</span> p2 <span class="token operator">=</span> p2<span class="token punctuation">,</span> p1            self<span class="token punctuation">.</span>parents<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">=</span> p1            self<span class="token punctuation">.</span>size<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">+=</span> self<span class="token punctuation">.</span>size<span class="token punctuation">[</span>p2<span class="token punctuation">]</span></code></pre><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://cp-algorithms.com/data_structures/disjoint_set_union.html#toc-tgt-2">cp-algorihms: Disjoint Set Union</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graph </tag>
            
            <tag> Trees </tag>
            
            <tag> Disjoint Set Union </tag>
            
            <tag> DSA Tutorial Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021 年「資訊科技產業專案設計」課程：公司面試的應對</title>
      <link href="/2021/12/14/jserv_guts4tech_live_1214/"/>
      <url>/2021/12/14/jserv_guts4tech_live_1214/</url>
      
        <content type="html"><![CDATA[<blockquote><p>內容待整理</p></blockquote><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://docs.google.com/presentation/d/1B698yDI6otlaVQc9A3iKmXJ9Yjo9-5Av1TMjSxQjqck/edit#slide=id.gcb1ca48d35_0_1">資訊科技產業專案設計:公司面試的應對</a></p>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Persistent Segment Tree</title>
      <link href="/2021/12/13/Trees-Persistent-Segment-Tree/"/>
      <url>/2021/12/13/Trees-Persistent-Segment-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="Persistent-Segment-Tree"><a href="#Persistent-Segment-Tree" class="headerlink" title="Persistent Segment Tree"></a>Persistent Segment Tree</h1><p>中文名為<strong>可持久化線段樹</strong>，也被稱為<strong>主席樹</strong></p><h2 id="Persistent-Data-Structure"><a href="#Persistent-Data-Structure" class="headerlink" title="Persistent Data Structure"></a>Persistent Data Structure</h2><p>可持久化資料結構（Persistent data structure）是一種能夠在修改之後其保留歷史版本（即可以在保留原來數據的基礎上進行修改——比如增添、刪除、賦值）的資料結構。這種資料結構實際上是不可變對象，<strong>因為相關操作不會直接修改被保存的數據，而是會在原版本上產生一個新分支</strong>。</p><h2 id="Persistent-Segment-Tree-1"><a href="#Persistent-Segment-Tree-1" class="headerlink" title="Persistent Segment Tree"></a>Persistent Segment Tree</h2><blockquote><p>常見的使用情境像是從區間<code>nums[l:r]</code>中取k-th小的數值。</p></blockquote><p>本文假設讀者已知從一個固定的線段樹中取出第k-th小的數值。若我們對nums中的每個前綴陣列都有一棵segment tree，如下圖：</p><pre class=" language-js"><code class="language-js"><span class="token function">seg_tree</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token punctuation">:</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> where idx <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">~</span> n</code></pre><p>則對任意子陣列nums[l:r]，便能透過差分的概念組出該子陣列的segment tree，例如</p><pre class=" language-js"><code class="language-js"><span class="token function">seg_tree</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">:</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">seg_tree</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token punctuation">:</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">seg_tree</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token punctuation">:</span>l<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><blockquote><p>要找[l,r]的統計信息，只要用[0,r]減去[0,l-1]的統計信息即可</p></blockquote><h3 id="Space-Optimization"><a href="#Space-Optimization" class="headerlink" title="Space Optimization"></a>Space Optimization</h3><p>但如果我們針對每個前綴都建一棵獨立的線段樹，顯然成本過高，但我們能發現，每次在線段樹中多插入一個數值，只會有log(n)的節點被修改。</p><blockquote><p>實際上我們每多建立一棵樹，只要新增被修改的節點就好，其餘的部分可接上原本就存在的節點。</p></blockquote><p>下圖是一個統計1~6中，每個數字數量的segment tree，可看到初始的樹(黑)沒有任何數字，若依序放入數字4(藍),3(橘)和2(紫)，各自造成若干節點的改變，並形成四棵線段樹。</p><img src="/images/persistent_seg_tree/tree2.png" width="75%" height="75%"><h3 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h3><p>建立所有線段樹，假設nums有n個數值，將所有數值依照大小<code>離散化</code>，並建一個初始全為0的segment tree，此時應有<code>2n-1</code>個節點，接著依序插入離散化後的數值，每次插入有<code>log(n)</code>個節點被更新</p><ul><li>Space Complexity: <code>O(n*log(n))</code></li><li>Time Complexity: <ul><li>build seg trees: <code>O(n*log(n))</code></li><li>query: <code>O(log(n))</code></li></ul></li></ul><h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> cnt<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>cnt <span class="token operator">=</span> cnt        self<span class="token punctuation">.</span>left <span class="token operator">=</span> None        self<span class="token punctuation">.</span>right <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">PerSegTree</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> minval<span class="token punctuation">,</span> maxval<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Persistent Segment Tree"""</span>        self<span class="token punctuation">.</span>minval <span class="token operator">=</span> minval        self<span class="token punctuation">.</span>maxval <span class="token operator">=</span> maxval        self<span class="token punctuation">.</span>versions <span class="token operator">=</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>self<span class="token punctuation">.</span>minval<span class="token punctuation">,</span> self<span class="token punctuation">.</span>maxval<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># versions of tree</span>            <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>        node <span class="token operator">=</span> Node<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">==</span> r<span class="token punctuation">:</span>            <span class="token keyword">return</span> node        mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        node<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>l<span class="token punctuation">,</span> mid<span class="token punctuation">)</span>        node<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span>        <span class="token keyword">return</span> node        <span class="token keyword">def</span> <span class="token function">_update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prenode<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 受到影響的節點，創立新的node</span>        node <span class="token operator">=</span> Node<span class="token punctuation">(</span>prenode<span class="token punctuation">.</span>cnt <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">==</span> r<span class="token punctuation">:</span>            <span class="token keyword">return</span> node        mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        <span class="token keyword">if</span> val <span class="token operator">&lt;=</span> mid<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 往左邊更新，右子樹接上舊的節點</span>            node<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>_update<span class="token punctuation">(</span>prenode<span class="token punctuation">.</span>left<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> val<span class="token punctuation">)</span>            node<span class="token punctuation">.</span>right <span class="token operator">=</span> prenode<span class="token punctuation">.</span>right        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 往右更新，左子樹接上舊的節點</span>            node<span class="token punctuation">.</span>left <span class="token operator">=</span> prenode<span class="token punctuation">.</span>left            node<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>_update<span class="token punctuation">(</span>prenode<span class="token punctuation">.</span>right<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> val<span class="token punctuation">)</span>        <span class="token keyword">return</span> node    <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>        prenode <span class="token operator">=</span> self<span class="token punctuation">.</span>versions<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>versions<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_update<span class="token punctuation">(</span>prenode<span class="token punctuation">,</span> self<span class="token punctuation">.</span>minval<span class="token punctuation">,</span> self<span class="token punctuation">.</span>maxval<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">_get_kth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node1<span class="token punctuation">,</span> node2<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> l <span class="token operator">==</span> r<span class="token punctuation">:</span>            <span class="token keyword">return</span> l        mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        <span class="token comment" spellcheck="true"># 差分，計算versions[v1:v2]在左子區間中有多少數量</span>        left_cnt <span class="token operator">=</span> node2<span class="token punctuation">.</span>left<span class="token punctuation">.</span>cnt <span class="token operator">-</span> node1<span class="token punctuation">.</span>left<span class="token punctuation">.</span>cnt        <span class="token keyword">if</span> k <span class="token operator">&lt;=</span> left_cnt<span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>_get_kth<span class="token punctuation">(</span>node1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> node2<span class="token punctuation">.</span>left<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> k<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>_get_kth<span class="token punctuation">(</span>node1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> node2<span class="token punctuation">.</span>right<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> k <span class="token operator">-</span> left_cnt<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">get_kth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> idx1<span class="token punctuation">,</span> idx2<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_get_kth<span class="token punctuation">(</span>self<span class="token punctuation">.</span>versions<span class="token punctuation">[</span>idx1<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>versions<span class="token punctuation">[</span>idx2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>minval<span class="token punctuation">,</span> self<span class="token punctuation">.</span>maxval<span class="token punctuation">,</span> k<span class="token punctuation">)</span></code></pre><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://oi-wiki.org/ds/persistent-seg/">Oi-Wiki: 可持久化線段樹</a></li><li><a href="https://blog.csdn.net/hzerotole/article/details/109633562">主席树（可持久化权值线段树）</a></li><li><a href="https://cp-algorithms.com/data_structures/segment_tree.html#toc-tgt-12">CP-Algorihms: Persistent Segment Tree</a></li><li><a href="https://en.wikipedia.org/wiki/Persistent_data_structure">Wiki: Persistent data structure</a></li><li><a href="https://oi.men.ci/bzoj-3673/">「BZOJ 3673」可持久化并查集 - 可持久化线段树</a></li></ul><h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><ul><li><a href="https://www.spoj.com/problems/DQUERY/">D-Query</a><ul><li>求区间内不重复的数的个数。扫描数列建立可持久化线段树，第i个数若第一次出现，则在线段树中的位置i加1</li><li>若不是第一次出现，将上次出现的位置减1，在本次位置加1</li><li>对于每个询问的区间 [L,R]，在第R个版本上的线段树只有前R个数，在线段树上查询位置L，对经过的区间中的和进行累计即可</li></ul></li><li>POJ 2104 K-th Number</li><li><a href="https://www.luogu.com.cn/problem/P2048">P2048 [NOI2010] 超级钢琴</a><ul><li>给一个长度为n的序列{a_i}，定义一个区间<code>[l, r]</code>的价值为这个区间中数的总和，求区间长度在<code>[L, R]</code>之间的所有区间中，价值最大的k个区间的价值总和。<ul><li>將每個左邊界i，在滿足長度下，挑出價值最大的區間<code>[i, r_i]</code>放入heap中</li><li>從heap中pop價值最大的區間<code>[idx, r_idx]</code></li><li>並重新挑選出對idx而言滿足條件，<strong>且不重複挑選下</strong>，價值最大的區間<code>[idx, r2_idx]</code>再放入heap中</li></ul></li></ul></li><li><a href="https://www.luogu.com.cn/problem/P3919">P3919 【模板】可持久化线段树 1（可持久化数组）</a></li><li>BZOJ 3673: 可持久化并查集 - 可持久化线段树</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Persistent Segment Tree </tag>
            
            <tag> Segment Tree </tag>
            
            <tag> DSA Tutorial Persistent Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Daniel 職場觀察】Google、微軟、Twitter 新 CEO：印度裔憑什麼攻佔美國 500 大企業？</title>
      <link href="/2021/12/11/daniel_workplace_observation/"/>
      <url>/2021/12/11/daniel_workplace_observation/</url>
      
        <content type="html"><![CDATA[<h1 id="【Daniel-職場觀察】Google、微軟、Twitter-新-CEO：印度裔憑什麼攻佔美國-500-大企業？"><a href="#【Daniel-職場觀察】Google、微軟、Twitter-新-CEO：印度裔憑什麼攻佔美國-500-大企業？" class="headerlink" title="【Daniel 職場觀察】Google、微軟、Twitter 新 CEO：印度裔憑什麼攻佔美國 500 大企業？"></a><a href="https://www.inside.com.tw/article/25935-ceo"><font color="LightSalmon" size=5><strong>【Daniel 職場觀察】Google、微軟、Twitter 新 CEO：印度裔憑什麼攻佔美國 500 大企業？</strong></font></a></h1><p>很喜歡這篇文章，但我怕整篇複製違反著作權法，只放上幾個大標題，對原文感興趣者請自行進入連結觀看，希望有朝一日能漸漸培養出這些能力。</p><h3 id="【特質一】「語言」＋「溝通」"><a href="#【特質一】「語言」＋「溝通」" class="headerlink" title="【特質一】「語言」＋「溝通」"></a>【特質一】「語言」＋「溝通」</h3><h3 id="【特質二】「理工」＋「管理」"><a href="#【特質二】「理工」＋「管理」" class="headerlink" title="【特質二】「理工」＋「管理」"></a>【特質二】「理工」＋「管理」</h3><h3 id="【特質三】「謙遜」＋「強勢」"><a href="#【特質三】「謙遜」＋「強勢」" class="headerlink" title="【特質三】「謙遜」＋「強勢」"></a>【特質三】「謙遜」＋「強勢」</h3><h3 id="【特質四】「混亂」＋「彈性」"><a href="#【特質四】「混亂」＋「彈性」" class="headerlink" title="【特質四】「混亂」＋「彈性」"></a>【特質四】「混亂」＋「彈性」</h3><blockquote><p><strong>「你必須保持開放的心胸，如果你只鎖定一個想法，那就是死路一條。」</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Personality </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Personality </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 913. Cat and Mouse</title>
      <link href="/2021/12/09/Leetcode0913-Cat-and-Mouse/"/>
      <url>/2021/12/09/Leetcode0913-Cat-and-Mouse/</url>
      
        <content type="html"><![CDATA[<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQqCjL5wtwnzZg6umbXf9hvGNadI1yVmWSlje7ct3hfeuikITNkUXo3TfNd0YL6nN6xDgQ&usqp=CAU" alt="cat and mouse"></p><h1 id="Leetcode-913-Cat-and-Mouse"><a href="#Leetcode-913-Cat-and-Mouse" class="headerlink" title="Leetcode 913: Cat and Mouse"></a>Leetcode 913: Cat and Mouse</h1><h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p>給一個graph，其中老鼠在節點1，貓在節點2，出口在節點0。老鼠跟貓輪流移動一步，由老鼠先走，且滿足下面規則：</p><ul><li>貓跟老鼠永遠都做最優行動</li><li>貓不能走到出口也就是位置0</li><li>老鼠走到出口，則老鼠贏，回傳1</li><li>貓跟老鼠在同一個位置，貓贏，回傳2</li><li>如果遊戲無法結束，則平局，回傳0</li></ul><h2 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h2><p>這一題的難點在於，明明知道一定是DP問題，其中DP狀態可以定義為 (m, c, t)</p><ul><li>m: 老鼠的位置</li><li>c: 貓的位置</li><li>t: 輪到誰移動 (0老鼠，1貓)</li></ul><p>但尷尬的是，我們卻無法像是一般DP一樣有一個好的判停方式，這是什麼意思？我們比較下面幾個DP結構</p><h3 id="DP概念"><a href="#DP概念" class="headerlink" title="DP概念"></a>DP概念</h3><p>我們將分別展示一般的DP及有環的DP</p><h4 id="常見的DP路徑圖"><a href="#常見的DP路徑圖" class="headerlink" title="常見的DP路徑圖"></a>常見的DP路徑圖</h4><ul><li>以下圖而言我們首先會在V8判定最終結果</li><li>由於V5, V6, V7都依賴V8，便能進一步得知</li><li>依此類推直到推得V0的答案</li></ul><img src="/images/CatAndMouse_DP1.png" width="30%" height="30%"><ul><li>以下圖而言，首先會判定所有葉節點</li><li>接著把只依賴葉節點的所有點又再判定一次，以此類推<img src="/images/CatAndMouse_DP2.png" width="30%" height="30%"></li></ul><blockquote><p>不論是哪一種圖，都有一個很強大的性質，那就是<br><font color="LightSalmon" size=5><strong>依賴路徑中不存在環</strong></font></p></blockquote><h4 id="存在環的DP"><a href="#存在環的DP" class="headerlink" title="存在環的DP"></a>存在環的DP</h4><ul><li>F18依賴F16及F17</li><li>F16依賴F15及F19</li><li>F19又依賴F18<img src="/images/CatAndMouse_DP3.png" width="30%" height="30%"></li></ul><p><strong>此時就形成了一個環狀的DP，導致DP變成一種雞蛋問題</strong></p><ul><li>對F16而言，可以得到F15的結果，仍在等待F19</li><li>結果F19卻在等待F18，而F18卻在等F16</li></ul><h3 id="解決環狀DP"><a href="#解決環狀DP" class="headerlink" title="解決環狀DP"></a>解決環狀DP</h3><p>一般來說，這種情況下確實會無解。但某些情況下，對F16而言，未必非得知道F15及F19才能有答案。</p><blockquote><p>以本題來說，若當前狀態為 (m, c, t)</p><ul><li><strong>對角色t來說，只要存在一種移動方式確認為t的勝利，縱使不知道往其他方向的移動結果，這個狀態仍然是t的必勝狀態</strong></li><li><strong>若當前狀態的所有移動方式，都是已確認t會輸的狀態，顯然當前狀態也是t必輸的狀態</strong></li></ul></blockquote><h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><blockquote><p>因應上述的結論，以本題來說可以發展出一個策略</p><ul><li>首先挑出能求解的狀態，也就是(x,x,t)為貓的勝利，(0,x,t)為老鼠勝利，注意本題貓不能站在0的位置，將這些有解的狀態放入queue中</li><li>從queue中依序取出一種有解的狀態(m, c, t)，檢查該狀態的母節點是否能得到解，注意母節點是輪到對手移動的回合<ul><li><strong>母節點有解的方式有 (1)對手走到當前狀態就獲勝, (2)對手已經沒有任何能獲勝的其他路徑</strong></li></ul></li><li><strong>若母節點能得到解，將其放入queue中</strong></li></ul></blockquote><h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>實踐上節的策略</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">catMouseGame</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> graph<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>graph<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># calculate degree of each state</span>        degrees <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">2</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#(m,c,t)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">continue</span>                degrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> len<span class="token punctuation">(</span>graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                degrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> len<span class="token punctuation">(</span>graph<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token keyword">in</span> graph<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># init dp and queue by known state</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">2</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#(m,c,t)</span>        queue <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            states <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>            results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>m<span class="token punctuation">,</span>c<span class="token punctuation">,</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> rv <span class="token keyword">in</span> zip<span class="token punctuation">(</span>states<span class="token punctuation">,</span> results<span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> rv            queue<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>states<span class="token punctuation">)</span>                <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># for each known state, traversal their parents, checking whether its parent could come up the answer or not</span>            m<span class="token punctuation">,</span> c<span class="token punctuation">,</span> t <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>            rv <span class="token operator">=</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">[</span>t<span class="token punctuation">]</span>            <span class="token keyword">if</span> t <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># mouse</span>                <span class="token keyword">for</span> pre <span class="token keyword">in</span> graph<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> pre <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                        <span class="token keyword">continue</span>                    <span class="token comment" spellcheck="true"># 對貓而言，rv=2，所以只要能走到(m,c,t)就贏了。但若rv=1，則不去走，除非所有可以走的路徑都是rv=1</span>                    <span class="token keyword">if</span> rv <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> pre<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        degrees<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                        <span class="token keyword">if</span> degrees<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                            dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>                            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> pre<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># cat</span>                <span class="token keyword">for</span> pre <span class="token keyword">in</span> graph<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> dp<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                        <span class="token keyword">continue</span>                                        <span class="token comment" spellcheck="true"># 對老鼠而言剛好跟貓相反</span>                    <span class="token keyword">if</span> rv <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        degrees<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                        <span class="token keyword">if</span> degrees<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                            dp<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>                            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></code></pre><ul><li>時間複雜度：O(n^3)<ul><li>狀態有2*n^2種，每個狀態最多有n個節點相鄰</li></ul></li><li>空間複雜度：O(n^2)</li></ul><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>總共n個點，老鼠如果走了n步還沒到終點也沒被貓逮到，則平局。找不到一個好的證明，不過有看到一個我比較能接受的解釋</p><blockquote><p>老鼠至多 n - 1 步就可以到達 0，我們記從 1 到 0 的這條路徑為 path。 如果第 n 步老鼠沒有到達 0 的話，就說明在某個時刻，老鼠偏離了原本的路徑path，為什麼會偏移呢？</p><p>說明在前面的某一點 p，貓在旁邊候著。貓到點 p 的距離小於等於老鼠到點 p 的距離。 （注意可以有多個這樣的點 p, 無論老鼠選取那條通往 0 的路徑，路上都有一個這樣的點，老鼠會在這個點被貓逮到）。 而老鼠不經過 p 的話又不可能到達 0。</p></blockquote><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">catMouseGame</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> graph<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        @lru_cache<span class="token punctuation">(</span>None<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> t <span class="token operator">==</span> int<span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>len<span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>            <span class="token keyword">if</span> x <span class="token operator">==</span> y<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">2</span>            <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token number">1</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">%</span> <span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> any<span class="token punctuation">(</span>search<span class="token punctuation">(</span>t<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> x_nxt<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token keyword">for</span> x_nxt <span class="token keyword">in</span> graph<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                                   <span class="token keyword">return</span> <span class="token number">1</span>                <span class="token keyword">if</span> any<span class="token punctuation">(</span>search<span class="token punctuation">(</span>t<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> x_nxt<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token keyword">for</span> x_nxt <span class="token keyword">in</span> graph<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                              <span class="token keyword">return</span> <span class="token number">0</span>                <span class="token keyword">return</span> <span class="token number">2</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> any<span class="token punctuation">(</span>search<span class="token punctuation">(</span>t<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y_nxt<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">2</span> <span class="token keyword">for</span> y_nxt <span class="token keyword">in</span> graph<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token keyword">if</span> y_nxt<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token number">2</span>                <span class="token keyword">if</span> any<span class="token punctuation">(</span>search<span class="token punctuation">(</span>t<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y_nxt<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token keyword">for</span> y_nxt <span class="token keyword">in</span> graph<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token keyword">if</span> y_nxt<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                      <span class="token keyword">return</span> <span class="token number">0</span>                <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">return</span> search<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span></code></pre><ul><li>時間複雜度：O(n^4)<ul><li>個人覺得是狀態n^3再乘以n，不確定為何有人說是 (n^2)*m，如果有人能幫我解惑就好了</li></ul></li><li>空間複雜度：O(n^3)</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://leetcode.com/problems/cat-and-mouse-ii/">Leetcode 1728. Cat and Mouse II</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> 環狀DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode Contest Review - Weekly 270</title>
      <link href="/2021/12/08/Leetcode-Contest-Review-Weekly270/"/>
      <url>/2021/12/08/Leetcode-Contest-Review-Weekly270/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/LeetcodeIcon.png"></p><h2 id="Leetcode-Weekly-Contest-270-Review"><a href="#Leetcode-Weekly-Contest-270-Review" class="headerlink" title="Leetcode Weekly Contest 270 Review"></a>Leetcode Weekly Contest 270 Review</h2><p>這場打得不太好，除了第四題為<strong>圖論的一筆畫問題</strong>確實不會之外，在前三題的解題過程中都有藏有許多瑕疵需要好好反省</p><h3 id="Q1-LC-2094-Finding-3-Digit-Even-Numbers"><a href="#Q1-LC-2094-Finding-3-Digit-Even-Numbers" class="headerlink" title="Q1: LC-2094. Finding 3-Digit Even Numbers"></a>Q1: LC-2094. Finding 3-Digit Even Numbers</h3><p>第一題正常來說都要秒解，但這題我不但TLE一次還寫了十分鐘。題目是從pool中任挑三個數字排成一排，並由小到大輸出所有不重複的狀況。</p><p>我的程式簡單來說就是把pool跑permutation並只做前三項，第一版繳交時是在6分鐘的時候，程式碼基本上都寫對，也有在idx=3的時候輸出答案，<strong>但是程式碼內竟然沒有在idx=3的時候return</strong>，導致繼續作idx&gt;3的部分，最終TLE，最後找bug並做了一些其實不用的優化，花了10分鐘加上TLE才修正。</p><h3 id="Q2-LC-2095-Delete-the-Middle-Node-of-a-Linked-List"><a href="#Q2-LC-2095-Delete-the-Middle-Node-of-a-Linked-List" class="headerlink" title="Q2: LC-2095. Delete the Middle Node of a Linked List"></a>Q2: LC-2095. Delete the Middle Node of a Linked List</h3><p>從LinkedList中找到特定節點並刪除，這題我覺得寫得還算快，僅花費4分鐘。</p><h3 id="Q3-LC-2096-Step-By-Step-Directions-From-a-Binary-Tree-Node-to-Another"><a href="#Q3-LC-2096-Step-By-Step-Directions-From-a-Binary-Tree-Node-to-Another" class="headerlink" title="Q3: LC-2096. Step-By-Step Directions From a Binary Tree Node to Another"></a>Q3: LC-2096. Step-By-Step Directions From a Binary Tree Node to Another</h3><p>這題我覺得程式碼寫得很冗，題目希望從一棵樹中，輸出從某個點到另一個點的最短路徑。</p><p>這題程式碼的部分特別難看，一堆if區塊，非常瑣碎，導致寫了整整12分鐘。</p><p>有看到一種做法，像這種只給樹根的二元樹，而且又不是從樹根為起點，<strong>可以將整棵樹轉換為adjacent matrix</strong>，之後便能透過adj直接從指定起點往外移動。</p><h3 id="Q4-LC-2097-Valid-Arrangement-of-Pairs"><a href="#Q4-LC-2097-Valid-Arrangement-of-Pairs" class="headerlink" title="Q4: LC-2097. Valid Arrangement of Pairs"></a>Q4: LC-2097. Valid Arrangement of Pairs</h3><p>這題可說是一筆畫問題的模板題，一筆畫問題是一個圖論經典問題，沒看過算是我不學無術。</p><p>值得一提的是，其實我在想得過程中是有點接近正確答案的，當時在思考要如何把某另一條路徑插在目前的路徑上。</p><p>仔細想想，這就是divide and conquer或是stack的思想。不馬上輸出目前的答案，先把另一條路徑走完並輸出後再把其他的也補上。</p><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>沒能完賽，26分鐘寫3題，加上1次TLE：總名次436/12931</p><hr><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ul><li>不要求程式碼逐行檢查，但是判停條件的位置最好再看一下</li><li>有些二元樹的題目可以轉換成adjacent matrix會更容易寫</li><li>Euler Path&amp;Circle以及Hierholzer’s Algorithm需要自己去念書</li></ul>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Competitive Programming </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Leetcode Contest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修正hexo-prism-plugin，大括號變為`&amp;#123;`和`&amp;#125`</title>
      <link href="/2021/12/08/fix-curly-bracket-in-hexo-prism-plugin/"/>
      <url>/2021/12/08/fix-curly-bracket-in-hexo-prism-plugin/</url>
      
        <content type="html"><![CDATA[<h1 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h1><p>使用hexo-prism-plugin，在程式區塊中，左右大括號會自動被轉為html語法，也就是<code>&amp;#123;</code>和<code>&amp;#125</code>。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ol><li>找到 <code>/node_modules\hexo-prism-plugin\src\index.js</code></li><li>將const map修改為</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token string">'&amp;#39;'</span><span class="token punctuation">:</span> <span class="token string">'\''</span><span class="token punctuation">,</span>  <span class="token string">'&amp;amp;'</span><span class="token punctuation">:</span> <span class="token string">'&amp;'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;gt;'</span><span class="token punctuation">:</span> <span class="token string">'>'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;lt;'</span><span class="token punctuation">:</span> <span class="token string">'&lt;'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;quot;'</span><span class="token punctuation">:</span> <span class="token string">'"'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;#123;'</span><span class="token punctuation">:</span> <span class="token string">'{'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;#125;'</span><span class="token punctuation">:</span> <span class="token string">'}'</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://github.com/ele828/hexo-prism-plugin/issues/61">hexo-prism-plugin: curly bracket issue</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eulerian Circuit and Path</title>
      <link href="/2021/12/07/Graph-Euler-Circuit/"/>
      <url>/2021/12/07/Graph-Euler-Circuit/</url>
      
        <content type="html"><![CDATA[<h1 id="Euler-Circuit"><a href="#Euler-Circuit" class="headerlink" title="Euler Circuit"></a>Euler Circuit</h1><h2 id="經典問題"><a href="#經典問題" class="headerlink" title="經典問題"></a>經典問題</h2><h3 id="Seven-Bridges-of-Konigsberg"><a href="#Seven-Bridges-of-Konigsberg" class="headerlink" title="Seven Bridges of Königsberg"></a>Seven Bridges of Königsberg</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5d/Konigsberg_bridges.png/300px-Konigsberg_bridges.png" alt="七橋問題"></p><p>這是著名的七橋問題，嘗試找一條可以經過七座橋各一次，然後<strong>回到原處的路線</strong>。</p><p>由於每座橋只能穿過一次，對圖上的某一個點來看，一旦從某座橋進入，就要從另一座橋走出去。所以，只要看到有個節點有奇數個邊，就表示有一條橋可以走入該節點卻走不出去。</p><h3 id="Eulerian-Path"><a href="#Eulerian-Path" class="headerlink" title="Eulerian Path"></a>Eulerian Path</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Blender3D_HouseOfStNiclas.gif/83px-Blender3D_HouseOfStNiclas.gif" alt="一筆畫問題"></p><p>又稱<strong>一筆畫問題</strong>，源於七橋問題，對於一個給定的圖，怎樣判斷是否存在著一個恰好包含了所有的邊，並且沒有重複的路徑</p><hr><h2 id="判斷是否滿足Euler"><a href="#判斷是否滿足Euler" class="headerlink" title="判斷是否滿足Euler"></a>判斷是否滿足Euler</h2><blockquote><p>滿足歐拉路徑不一定有歐拉回路</p></blockquote><p><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Euler1.png"></p><h3 id="無向圖"><a href="#無向圖" class="headerlink" title="無向圖"></a>無向圖</h3><ul><li>Eulerian Circuit<ol><li>All vertices with non-zero degree are connected. We don’t care about vertices with zero degree because they don’t belong to Eulerian Cycle or Path (we only consider all edges). </li><li>All vertices have even degree.</li></ol></li><li>Eulerian Path<ol><li>Same as condition (1) for Eulerian Circuit </li><li>If zero or two vertices have odd degree and all other vertices have even degree. Note that only one vertex with odd degree is not possible in an undirected graph (sum of all degrees is always even in an undirected graph)</li></ol></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 無向圖中判定歐拉回路及路徑</span>    odd <span class="token operator">=</span> vertex_num_with_odd_degree<span class="token punctuation">(</span>graph<span class="token punctuation">)</span>    <span class="token keyword">if</span> odd <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Eulerian Circuit"</span><span class="token punctuation">)</span>    <span class="token keyword">elif</span> odd <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Eulerian Path"</span><span class="token punctuation">)</span>    <span class="token keyword">elif</span> odd <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"no Eulerian"</span><span class="token punctuation">)</span></code></pre><h3 id="有向圖"><a href="#有向圖" class="headerlink" title="有向圖"></a>有向圖</h3><ul><li>Eulerian Circuit<ol><li>All vertices with nonzero degree belong to a single strongly connected component. </li><li>In degree is equal to the out degree for every vertex.</li></ol></li><li>Eulerian Path<ol><li>at most one vertex has (out-degree) − (in-degree) = 1</li><li>at most one vertex has (in-degree) − (out-degree) = 1</li><li>In degree is equal to the out degree for every other vertex, and these vertex should belong to a single connected component of the underlying undirected graph.</li></ol></li></ul><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="Hierholzer’s-Algorithm"><a href="#Hierholzer’s-Algorithm" class="headerlink" title="Hierholzer’s Algorithm"></a>Hierholzer’s Algorithm</h3><p><font color="LightSalmon" size=5><strong>不論有向圖、無向圖、歐拉回路或歐拉路徑都能解</strong></font></p><h4 id="有向圖中找歐拉回路"><a href="#有向圖中找歐拉回路" class="headerlink" title="有向圖中找歐拉回路"></a>有向圖中找歐拉回路</h4><ol><li>先確認該圖滿足歐拉回路</li><li>從任意一個點v出發，隨便走一條尚未選過的邊直到卡住，此時必然是卡在點v，因為每個點的入度應該要等同出度，至此所走過的路徑已經是一個歐拉回路，但不一定剛好走過圖中的每個邊</li><li>退回曾路過的某個點w，若點w還有未曾走過的邊，則從w往另外一條未走過的邊移動，必然最終也會形成另一組封閉路徑並停在w，不斷做這件事情直到所有的邊都被走過</li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">EulerCircuit</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">find_circuit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> adj<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 假設adj已經滿足歐拉回路</span>        self<span class="token punctuation">.</span>adj <span class="token operator">=</span> adj        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                start <span class="token operator">=</span> list<span class="token punctuation">(</span>adj<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>start<span class="token punctuation">,</span> <span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>adj<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">:</span>            y <span class="token operator">=</span> self<span class="token punctuation">.</span>adj<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            cur<span class="token punctuation">.</span>append<span class="token punctuation">(</span>y<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>y<span class="token punctuation">,</span> cur<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>adj <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token number">0</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token number">2</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token number">3</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token number">4</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">}</span>res <span class="token operator">=</span> EulerCircuit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>find_circuit<span class="token punctuation">(</span>adj<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># res = [0, 1, 3, 4, 1, 2, 0]</span></code></pre><blockquote><ol><li>從0出發沿著紅線走回0，此時是一個封閉路徑為{0,1,2,0}，但藍線還沒走過</li><li>所以退回到點1並走藍線，又得到另一個封閉路徑{1,3,4,1}</li><li>將藍色路徑跟紅色路徑接起來就變成 {0,1,3,4,1,2,0}</li></ol></blockquote><p>實作上就是不能走的時候，pop資料回到先前的節點，直到遇到可以走的節點繼續繞其他路徑<br><img src="/images/euler_circuit.png" alt="EulerCircuit"></p><h4 id="無向圖找出歐拉回路-演算法筆記"><a href="#無向圖找出歐拉回路-演算法筆記" class="headerlink" title="無向圖找出歐拉回路 (演算法筆記)"></a>無向圖找出歐拉回路 (<a href="https://web.ntnu.edu.tw/~algo/Circuit.html#3">演算法筆記</a>)</h4><p><img src="/images/EulerCircuit7.png" alt="一個 Euler Circuit ，在某點相交，可拆成兩個 Euler Circuit "></p><p><img src="/images/EulerCircuit8.png" alt="兩個 Euler Circuit ，可在某點相接，合成一個 Euler Circuit 。"></p><p><img src="/images/EulerCircuit9.png" alt="大的 Euler Circuit 可拆成小的，小的可接成大的"></p><p>自然想到 Divide-and-Conquer Method，也就是在圖上<strong>隨意走一圈</strong>。未及之處，一定是一個（或數個） Euler Circuit 。</p><blockquote><p>Divide ：在圖上隨意走一圈。</p><p>Conquer：其餘部份遞迴下去。</p><p>Combine：其餘部分的Euler Circuit們，銜接到隨意走的那一圈。</p></blockquote><h4 id="有向圖中找歐拉路徑"><a href="#有向圖中找歐拉路徑" class="headerlink" title="有向圖中找歐拉路徑"></a>有向圖中找歐拉路徑</h4><ol><li>根據in-degree和out-degree的差確認是否有唯一起點，其餘相同</li></ol><h4 id="無向圖中找歐拉路徑"><a href="#無向圖中找歐拉路徑" class="headerlink" title="無向圖中找歐拉路徑"></a>無向圖中找歐拉路徑</h4><ol><li>根據degree的奇偶數量，確認是否能成為起點，其餘相同</li></ol><hr><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.geeksforgeeks.org/eulerian-path-and-circuit/">Geeksforgeeks: Eulerian path and circuit for undirected graph</a></li><li><a href="https://www.geeksforgeeks.org/euler-circuit-directed-graph/">Geeksforgeeks: Euler Circuit in a Directed Graph</a></li><li><a href="https://en.wikipedia.org/wiki/Eulerian_path">Wiki: Eulerian path</a></li><li><a href="https://web.ntnu.edu.tw/~algo/Circuit.html#3">演算法筆記: Euler Circuit</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graph </tag>
            
            <tag> DSA Tutorial Graph </tag>
            
            <tag> Euler Circuit </tag>
            
            <tag> Euler Path </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/2021/12/07/hello-world-hexo/"/>
      <url>/2021/12/07/hello-world-hexo/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/hexo_logo.jpg"></p><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><p>clear public, generate static files then deploy</p><pre class=" language-bash"><code class="language-bash">$ hexo cl$ hexo g -d</code></pre><h3 id="Font-of-Article"><a href="#Font-of-Article" class="headerlink" title="Font of Article"></a>Font of Article</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span> <span class="token key atrule">title</span><span class="token punctuation">:</span> Hello Hexo<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2021-12-07 02:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> Aaron<span class="token key atrule">img</span><span class="token punctuation">:</span> /images/hexo_logo.jpg <span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/hexo_logo.jpg <span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 <span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token key atrule">summary</span><span class="token punctuation">:</span> Hi<span class="token punctuation">,</span> welcom to Hexo. It's a short guideline to teach you how to use Hexo.<span class="token key atrule">categories</span><span class="token punctuation">:</span>   <span class="token punctuation">-</span> Hexo<span class="token key atrule">tags</span><span class="token punctuation">:</span>   <span class="token punctuation">-</span> Hexo<span class="token punctuation">---</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode Contest Review - Biweekly 66 &amp; Weekly 269</title>
      <link href="/2021/11/29/Leetcode-Contest-Review-Biweekly66-Weekly269/"/>
      <url>/2021/11/29/Leetcode-Contest-Review-Biweekly66-Weekly269/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/LeetcodeIcon.png"></p><h2 id="Leetcode-Biweekly-Contest-66-Review"><a href="#Leetcode-Biweekly-Contest-66-Review" class="headerlink" title="Leetcode Biweekly Contest 66 Review"></a>Leetcode Biweekly Contest 66 Review</h2><h3 id="Q1-LC-2085-Count-Common-Words-With-One-Occurrence"><a href="#Q1-LC-2085-Count-Common-Words-With-One-Occurrence" class="headerlink" title="Q1: LC-2085. Count Common Words With One Occurrence"></a>Q1: LC-2085. Count Common Words With One Occurrence</h3><p>簡單查數量的題目，比typing的速度而已</p><h3 id="Q2-LC-2086-Minimum-Number-of-Buckets-Required-to-Collect-Rainwater-from-Houses"><a href="#Q2-LC-2086-Minimum-Number-of-Buckets-Required-to-Collect-Rainwater-from-Houses" class="headerlink" title="Q2: LC-2086. Minimum Number of Buckets Required to Collect Rainwater from Houses"></a>Q2: LC-2086. Minimum Number of Buckets Required to Collect Rainwater from Houses</h3><p>明顯是greedy的題目，但實作時有點卡住，沒有理好要以房子為單位搜尋還是以空地為單位搜尋，多花了幾分鐘。</p><h3 id="Q3-LC-2087-Minimum-Cost-Homecoming-of-a-Robot-in-a-Grid"><a href="#Q3-LC-2087-Minimum-Cost-Homecoming-of-a-Robot-in-a-Grid" class="headerlink" title="Q3: LC-2087. Minimum Cost Homecoming of a Robot in a Grid"></a>Q3: LC-2087. Minimum Cost Homecoming of a Robot in a Grid</h3><p>只要看到最短距離，就腦殘想用Dijkstra，反而沒意識到這題所有的最短路徑都是最短距離，隨便挑一條greedy計算就可以了。時間浪費在實作dijkstra外加一個TLE</p><h3 id="Q4-LC-2088-Count-Fertile-Pyramids-in-a-Land"><a href="#Q4-LC-2088-Count-Fertile-Pyramids-in-a-Land" class="headerlink" title="Q4: LC-2088. Count Fertile Pyramids in a Land"></a>Q4: LC-2088. Count Fertile Pyramids in a Land</h3><p>明顯是DP問題，我的解法重複又冗長的程式碼太多，這部分應該包成function或是翻轉測資就好。</p><p>另外我解這種稍微複雜的題目，常常階段性的寫程式碼，例如這題我先寫一段程式，對每個點都找到往左及往右可以抵達的距離，但當下並沒有確定好下一步該做什麼，只是覺得這樣做有幫助，事後也確實是有幫助，並以此為基礎完成這題。值得反省的是，<strong>如果這麼做沒幫助的話，是否不但浪費時間，又限縮了自己後續思考問題的方式</strong>。</p><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>40分鐘完賽加上1次TLE：總名次160/8620</p><hr><h2 id="Leetcode-Weekly-Contest-269-Review"><a href="#Leetcode-Weekly-Contest-269-Review" class="headerlink" title="Leetcode Weekly Contest 269 Review"></a>Leetcode Weekly Contest 269 Review</h2><h3 id="Q1-LC-2089-Find-Target-Indices-After-Sorting-Array"><a href="#Q1-LC-2089-Find-Target-Indices-After-Sorting-Array" class="headerlink" title="Q1: LC-2089. Find Target Indices After Sorting Array"></a>Q1: LC-2089. Find Target Indices After Sorting Array</h3><p>比打字速度的題目</p><h3 id="Q2-LC-2090-K-Radius-Subarray-Averages"><a href="#Q2-LC-2090-K-Radius-Subarray-Averages" class="headerlink" title="Q2: LC-2090. K Radius Subarray Averages"></a>Q2: LC-2090. K Radius Subarray Averages</h3><p>固定遮罩的總合問題，也是看到就知道怎麼做。值得檢討的是我<strong>題目常常看一半就開始作答</strong>，做到一半的時候發覺欠缺了一些資訊才回去敘述中找，以本例來說我寫到一半才回去找遮罩寬度的定義以及輸出要落在什麼位置，算是蠻不好的習慣，另外也是同一個原因，一些需要事先定義的變數在寫的過程才一直補上，導致程式碼前幾行看起來沒有章法又混亂。</p><h3 id="Q3-LC-2091-Removing-Minimum-and-Maximum-From-Array"><a href="#Q3-LC-2091-Removing-Minimum-and-Maximum-From-Array" class="headerlink" title="Q3: LC-2091. Removing Minimum and Maximum From Array"></a>Q3: LC-2091. Removing Minimum and Maximum From Array</h3><p>我覺得這題寫得還不錯，只是有些程式碼看起來可以合併成一行才不會顯得有點冗，這場到寫完第三題共花7分鐘。</p><h3 id="Q4-LC-2092-Find-All-People-With-Secret"><a href="#Q4-LC-2092-Find-All-People-With-Secret" class="headerlink" title="Q4: LC-2092. Find All People With Secret"></a>Q4: LC-2092. Find All People With Secret</h3><p>明顯是依照時間處理DSU的問題。只要是時間順序的題目，都要記得「<strong>確認同一個時間內是否可能有多筆事件</strong>」，第一版繳交的答案就是沒意識到這件事情導致WA。為了處理同一時間產生的事件，需要在這個時間點分群以及判斷哪些群該被納入答案中，但我第二版沒處理好分群問題，浪費時間寫了一個現在看來不可思議的答案，當時直到寫完測試才發現問題，最後第三版才改對。因此單單這題花了27分鐘外加一個WA，大把時間浪費在解bug以及莫名其妙的錯誤，明顯也是沒想清楚就開始寫題目的壞習慣導致。</p><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>34分鐘完賽加上1次WA：總名次: 215/10907</p><hr><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul><li>題目及測資範圍都看完再作答 (cirtical)</li><li>做後續步驟前最好再問自己一遍真的想清楚了嗎 (cirtical)<ul><li>包含確認是否有必要先寫中間步驟的程式碼</li></ul></li><li>競速心態要調整，最好把時間都遮起來</li><li>時間序的題目要注意重複時間問題</li><li>冗長又重複的程式碼該包成function</li></ul>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Competitive Programming </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Leetcode Contest </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
